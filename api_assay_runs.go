/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AssayRunsApiService AssayRunsApi service
type AssayRunsApiService service

type ApiArchiveAssayRunsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunsArchive *AssayRunsArchive
}

func (r ApiArchiveAssayRunsRequest) AssayRunsArchive(assayRunsArchive AssayRunsArchive) ApiArchiveAssayRunsRequest {
	r.assayRunsArchive = &assayRunsArchive
	return r
}

func (r ApiArchiveAssayRunsRequest) Execute() (*AssayRunsArchivalChange, *http.Response, error) {
	return r.ApiService.ArchiveAssayRunsExecute(r)
}

/*
ArchiveAssayRuns Archive Assay Runs

Archive assay runs that are not embedded in a notebook entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveAssayRunsRequest
*/
func (a *AssayRunsApiService) ArchiveAssayRuns(ctx context.Context) ApiArchiveAssayRunsRequest {
	return ApiArchiveAssayRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayRunsArchivalChange
func (a *AssayRunsApiService) ArchiveAssayRunsExecute(r ApiArchiveAssayRunsRequest) (*AssayRunsArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRunsArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.ArchiveAssayRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayRunsArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetAssayRunsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunIds *string
}

// Comma-separated list of assay run IDs
func (r ApiBulkGetAssayRunsRequest) AssayRunIds(assayRunIds string) ApiBulkGetAssayRunsRequest {
	r.assayRunIds = &assayRunIds
	return r
}

func (r ApiBulkGetAssayRunsRequest) Execute() (*AssayRunsBulkGet, *http.Response, error) {
	return r.ApiService.BulkGetAssayRunsExecute(r)
}

/*
BulkGetAssayRuns Bulk get runs by ID

Bulk get runs by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetAssayRunsRequest
*/
func (a *AssayRunsApiService) BulkGetAssayRuns(ctx context.Context) ApiBulkGetAssayRunsRequest {
	return ApiBulkGetAssayRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayRunsBulkGet
func (a *AssayRunsApiService) BulkGetAssayRunsExecute(r ApiBulkGetAssayRunsRequest) (*AssayRunsBulkGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRunsBulkGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.BulkGetAssayRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs:bulk-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assayRunIds == nil {
		return localVarReturnValue, nil, reportError("assayRunIds is required and must be specified")
	}

	localVarQueryParams.Add("assayRunIds", parameterToString(*r.assayRunIds, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssayRunsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunsBulkCreateRequest *AssayRunsBulkCreateRequest
}

func (r ApiCreateAssayRunsRequest) AssayRunsBulkCreateRequest(assayRunsBulkCreateRequest AssayRunsBulkCreateRequest) ApiCreateAssayRunsRequest {
	r.assayRunsBulkCreateRequest = &assayRunsBulkCreateRequest
	return r
}

func (r ApiCreateAssayRunsRequest) Execute() (*AssayRunsBulkCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAssayRunsExecute(r)
}

/*
CreateAssayRuns Create 1 or more runs.

Create 1 or more runs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssayRunsRequest
*/
func (a *AssayRunsApiService) CreateAssayRuns(ctx context.Context) ApiCreateAssayRunsRequest {
	return ApiCreateAssayRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayRunsBulkCreateResponse
func (a *AssayRunsApiService) CreateAssayRunsExecute(r ApiCreateAssayRunsRequest) (*AssayRunsBulkCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRunsBulkCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.CreateAssayRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayRunsBulkCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssayRunRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunId string
}

func (r ApiGetAssayRunRequest) Execute() (*AssayRun, *http.Response, error) {
	return r.ApiService.GetAssayRunExecute(r)
}

/*
GetAssayRun Get a run

Get a run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assayRunId
 @return ApiGetAssayRunRequest
*/
func (a *AssayRunsApiService) GetAssayRun(ctx context.Context, assayRunId string) ApiGetAssayRunRequest {
	return ApiGetAssayRunRequest{
		ApiService: a,
		ctx: ctx,
		assayRunId: assayRunId,
	}
}

// Execute executes the request
//  @return AssayRun
func (a *AssayRunsApiService) GetAssayRunExecute(r ApiGetAssayRunRequest) (*AssayRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.GetAssayRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs/{assay_run_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assay_run_id"+"}", url.PathEscape(parameterToString(r.assayRunId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssayRunsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	schemaId *string
	minCreatedTime *int32
	maxCreatedTime *int32
	nextToken *string
	pageSize *int32
	ids *string
}

// ID of the assay run schema to filter by
func (r ApiListAssayRunsRequest) SchemaId(schemaId string) ApiListAssayRunsRequest {
	r.schemaId = &schemaId
	return r
}

// Filter by runs created after this unix timestamp
func (r ApiListAssayRunsRequest) MinCreatedTime(minCreatedTime int32) ApiListAssayRunsRequest {
	r.minCreatedTime = &minCreatedTime
	return r
}

// Filter by runs created before this unix timestamp
func (r ApiListAssayRunsRequest) MaxCreatedTime(maxCreatedTime int32) ApiListAssayRunsRequest {
	r.maxCreatedTime = &maxCreatedTime
	return r
}

// Token for pagination
func (r ApiListAssayRunsRequest) NextToken(nextToken string) ApiListAssayRunsRequest {
	r.nextToken = &nextToken
	return r
}

// Number of results to return. Defaults to 50, maximum of 100.
func (r ApiListAssayRunsRequest) PageSize(pageSize int32) ApiListAssayRunsRequest {
	r.pageSize = &pageSize
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListAssayRunsRequest) Ids(ids string) ApiListAssayRunsRequest {
	r.ids = &ids
	return r
}

func (r ApiListAssayRunsRequest) Execute() (*AssayRunsPaginatedList, *http.Response, error) {
	return r.ApiService.ListAssayRunsExecute(r)
}

/*
ListAssayRuns List runs

List runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAssayRunsRequest
*/
func (a *AssayRunsApiService) ListAssayRuns(ctx context.Context) ApiListAssayRunsRequest {
	return ApiListAssayRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayRunsPaginatedList
func (a *AssayRunsApiService) ListAssayRunsExecute(r ApiListAssayRunsRequest) (*AssayRunsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRunsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.ListAssayRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.schemaId == nil {
		return localVarReturnValue, nil, reportError("schemaId is required and must be specified")
	}

	localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	if r.minCreatedTime != nil {
		localVarQueryParams.Add("minCreatedTime", parameterToString(*r.minCreatedTime, ""))
	}
	if r.maxCreatedTime != nil {
		localVarQueryParams.Add("maxCreatedTime", parameterToString(*r.maxCreatedTime, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAutomationInputGeneratorsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunId string
	nextToken *string
	modifiedAt *string
}

// Token for pagination
func (r ApiListAutomationInputGeneratorsRequest) NextToken(nextToken string) ApiListAutomationInputGeneratorsRequest {
	r.nextToken = &nextToken
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListAutomationInputGeneratorsRequest) ModifiedAt(modifiedAt string) ApiListAutomationInputGeneratorsRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiListAutomationInputGeneratorsRequest) Execute() (*AutomationFileInputsPaginatedList, *http.Response, error) {
	return r.ApiService.ListAutomationInputGeneratorsExecute(r)
}

/*
ListAutomationInputGenerators list AutomationInputGenerators by Run

list AutomationInputGenerators by Run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assayRunId
 @return ApiListAutomationInputGeneratorsRequest
*/
func (a *AssayRunsApiService) ListAutomationInputGenerators(ctx context.Context, assayRunId string) ApiListAutomationInputGeneratorsRequest {
	return ApiListAutomationInputGeneratorsRequest{
		ApiService: a,
		ctx: ctx,
		assayRunId: assayRunId,
	}
}

// Execute executes the request
//  @return AutomationFileInputsPaginatedList
func (a *AssayRunsApiService) ListAutomationInputGeneratorsExecute(r ApiListAutomationInputGeneratorsRequest) (*AutomationFileInputsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationFileInputsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.ListAutomationInputGenerators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs/{assay_run_id}/automation-input-generators"
	localVarPath = strings.Replace(localVarPath, "{"+"assay_run_id"+"}", url.PathEscape(parameterToString(r.assayRunId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAutomationOutputProcessorsDeprecatedRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunId string
	nextToken *string
}

// Token for pagination
func (r ApiListAutomationOutputProcessorsDeprecatedRequest) NextToken(nextToken string) ApiListAutomationOutputProcessorsDeprecatedRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListAutomationOutputProcessorsDeprecatedRequest) Execute() (*DeprecatedAutomationOutputProcessorsPaginatedList, *http.Response, error) {
	return r.ApiService.ListAutomationOutputProcessorsDeprecatedExecute(r)
}

/*
ListAutomationOutputProcessorsDeprecated list AutomationOutputProcessors by Run

Deprecated in favor of '/automation-output-processors'. For each output config in the run config, will create an empty automationOutputProcessor for the run if one doesn't exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assayRunId
 @return ApiListAutomationOutputProcessorsDeprecatedRequest

Deprecated
*/
func (a *AssayRunsApiService) ListAutomationOutputProcessorsDeprecated(ctx context.Context, assayRunId string) ApiListAutomationOutputProcessorsDeprecatedRequest {
	return ApiListAutomationOutputProcessorsDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		assayRunId: assayRunId,
	}
}

// Execute executes the request
//  @return DeprecatedAutomationOutputProcessorsPaginatedList
// Deprecated
func (a *AssayRunsApiService) ListAutomationOutputProcessorsDeprecatedExecute(r ApiListAutomationOutputProcessorsDeprecatedRequest) (*DeprecatedAutomationOutputProcessorsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeprecatedAutomationOutputProcessorsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.ListAutomationOutputProcessorsDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs/{assay_run_id}/automation-output-processors"
	localVarPath = strings.Replace(localVarPath, "{"+"assay_run_id"+"}", url.PathEscape(parameterToString(r.assayRunId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveAssayRunsRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunsUnarchive *AssayRunsUnarchive
}

func (r ApiUnarchiveAssayRunsRequest) AssayRunsUnarchive(assayRunsUnarchive AssayRunsUnarchive) ApiUnarchiveAssayRunsRequest {
	r.assayRunsUnarchive = &assayRunsUnarchive
	return r
}

func (r ApiUnarchiveAssayRunsRequest) Execute() (*AssayRunsArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchiveAssayRunsExecute(r)
}

/*
UnarchiveAssayRuns Unarchive Assay Runs

Unarchive assay runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveAssayRunsRequest
*/
func (a *AssayRunsApiService) UnarchiveAssayRuns(ctx context.Context) ApiUnarchiveAssayRunsRequest {
	return ApiUnarchiveAssayRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayRunsArchivalChange
func (a *AssayRunsApiService) UnarchiveAssayRunsExecute(r ApiUnarchiveAssayRunsRequest) (*AssayRunsArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRunsArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.UnarchiveAssayRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayRunsUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssayRunRequest struct {
	ctx context.Context
	ApiService *AssayRunsApiService
	assayRunId string
	assayRunUpdate *AssayRunUpdate
}

func (r ApiUpdateAssayRunRequest) AssayRunUpdate(assayRunUpdate AssayRunUpdate) ApiUpdateAssayRunRequest {
	r.assayRunUpdate = &assayRunUpdate
	return r
}

func (r ApiUpdateAssayRunRequest) Execute() (*AssayRun, *http.Response, error) {
	return r.ApiService.UpdateAssayRunExecute(r)
}

/*
UpdateAssayRun Update a run

Update a run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assayRunId ID of the Run to be updated
 @return ApiUpdateAssayRunRequest
*/
func (a *AssayRunsApiService) UpdateAssayRun(ctx context.Context, assayRunId string) ApiUpdateAssayRunRequest {
	return ApiUpdateAssayRunRequest{
		ApiService: a,
		ctx: ctx,
		assayRunId: assayRunId,
	}
}

// Execute executes the request
//  @return AssayRun
func (a *AssayRunsApiService) UpdateAssayRunExecute(r ApiUpdateAssayRunRequest) (*AssayRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayRunsApiService.UpdateAssayRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-runs/{assay_run_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assay_run_id"+"}", url.PathEscape(parameterToString(r.assayRunId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayRunUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
