/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// EventsApiService EventsApi service
type EventsApiService service

type ApiListEventsRequest struct {
	ctx context.Context
	ApiService *EventsApiService
	pageSize *int32
	nextToken *string
	createdAtGte *string
	startingAfter *string
	eventTypes *string
	poll *bool
}

// Number of results to return. Defaults to 50, maximum of 100. 
func (r ApiListEventsRequest) PageSize(pageSize int32) ApiListEventsRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListEventsRequest) NextToken(nextToken string) ApiListEventsRequest {
	r.nextToken = &nextToken
	return r
}

// Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. \&quot;2020-05-23\&quot;. 
func (r ApiListEventsRequest) CreatedAtGte(createdAtGte string) ApiListEventsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Event ID after which events will be returned.
func (r ApiListEventsRequest) StartingAfter(startingAfter string) ApiListEventsRequest {
	r.startingAfter = &startingAfter
	return r
}

// Comma-separated list of event types to return.
func (r ApiListEventsRequest) EventTypes(eventTypes string) ApiListEventsRequest {
	r.eventTypes = &eventTypes
	return r
}

// When True, the API will always return a nextToken to enable polling events indefinitely.
func (r ApiListEventsRequest) Poll(poll bool) ApiListEventsRequest {
	r.poll = &poll
	return r
}

func (r ApiListEventsRequest) Execute() (*EventsPaginatedList, *http.Response, error) {
	return r.ApiService.ListEventsExecute(r)
}

/*
ListEvents List Events

List Events

## Event Sort Order

Events in Benchling are assigned a stable sort order that reflects when the event was processed (not created). The createdAt time is not the stable sorted order of events. For this reason event createdAt time may appear out of order.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEventsRequest
*/
func (a *EventsApiService) ListEvents(ctx context.Context) ApiListEventsRequest {
	return ApiListEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventsPaginatedList
func (a *EventsApiService) ListEventsExecute(r ApiListEventsRequest) (*EventsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.ListEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.createdAtGte != nil {
		localVarQueryParams.Add("createdAt.gte", parameterToString(*r.createdAtGte, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, ""))
	}
	if r.poll != nil {
		localVarQueryParams.Add("poll", parameterToString(*r.poll, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
