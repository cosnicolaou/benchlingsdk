/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"encoding/json"
	"fmt"
)

// NamingStrategy Specifies the behavior for automatically generated names when registering an entity. - NEW_IDS: Generate new registry IDs - IDS_FROM_NAMES: Generate registry IDs based on entity names - DELETE_NAMES: Generate new registry IDs and replace name with registry ID - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template - KEEP_NAMES: Keep existing entity names as registry IDs - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template 
type NamingStrategy string

// List of NamingStrategy
const (
	NEW_IDS NamingStrategy = "NEW_IDS"
	IDS_FROM_NAMES NamingStrategy = "IDS_FROM_NAMES"
	DELETE_NAMES NamingStrategy = "DELETE_NAMES"
	SET_FROM_NAME_PARTS NamingStrategy = "SET_FROM_NAME_PARTS"
	REPLACE_NAMES_FROM_PARTS NamingStrategy = "REPLACE_NAMES_FROM_PARTS"
	KEEP_NAMES NamingStrategy = "KEEP_NAMES"
	REPLACE_ID_AND_NAME_FROM_PARTS NamingStrategy = "REPLACE_ID_AND_NAME_FROM_PARTS"
)

// All allowed values of NamingStrategy enum
var AllowedNamingStrategyEnumValues = []NamingStrategy{
	"NEW_IDS",
	"IDS_FROM_NAMES",
	"DELETE_NAMES",
	"SET_FROM_NAME_PARTS",
	"REPLACE_NAMES_FROM_PARTS",
	"KEEP_NAMES",
	"REPLACE_ID_AND_NAME_FROM_PARTS",
}

func (v *NamingStrategy) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := NamingStrategy(value)
	for _, existing := range AllowedNamingStrategyEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid NamingStrategy", value)
}

// NewNamingStrategyFromValue returns a pointer to a valid NamingStrategy
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewNamingStrategyFromValue(v string) (*NamingStrategy, error) {
	ev := NamingStrategy(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for NamingStrategy: valid values are %v", v, AllowedNamingStrategyEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v NamingStrategy) IsValid() bool {
	for _, existing := range AllowedNamingStrategyEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to NamingStrategy value
func (v NamingStrategy) Ptr() *NamingStrategy {
	return &v
}

type NullableNamingStrategy struct {
	value *NamingStrategy
	isSet bool
}

func (v NullableNamingStrategy) Get() *NamingStrategy {
	return v.value
}

func (v *NullableNamingStrategy) Set(val *NamingStrategy) {
	v.value = val
	v.isSet = true
}

func (v NullableNamingStrategy) IsSet() bool {
	return v.isSet
}

func (v *NullableNamingStrategy) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableNamingStrategy(val *NamingStrategy) *NullableNamingStrategy {
	return &NullableNamingStrategy{value: val, isSet: true}
}

func (v NullableNamingStrategy) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableNamingStrategy) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

