/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// WorkflowTasksApiService WorkflowTasksApi service
type WorkflowTasksApiService service

type ApiArchiveWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTasksArchive *WorkflowTasksArchive
}

func (r ApiArchiveWorkflowTasksRequest) WorkflowTasksArchive(workflowTasksArchive WorkflowTasksArchive) ApiArchiveWorkflowTasksRequest {
	r.workflowTasksArchive = &workflowTasksArchive
	return r
}

func (r ApiArchiveWorkflowTasksRequest) Execute() (*WorkflowTasksArchivalChange, *http.Response, error) {
	return r.ApiService.ArchiveWorkflowTasksExecute(r)
}

/*
ArchiveWorkflowTasks Archive one or more workflow tasks

Archive one or more workflow tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) ArchiveWorkflowTasks(ctx context.Context) ApiArchiveWorkflowTasksRequest {
	return ApiArchiveWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WorkflowTasksArchivalChange
func (a *WorkflowTasksApiService) ArchiveWorkflowTasksExecute(r ApiArchiveWorkflowTasksRequest) (*WorkflowTasksArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTasksArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.ArchiveWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTasksArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCopyWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTasksBulkCopyRequest *WorkflowTasksBulkCopyRequest
}

func (r ApiBulkCopyWorkflowTasksRequest) WorkflowTasksBulkCopyRequest(workflowTasksBulkCopyRequest WorkflowTasksBulkCopyRequest) ApiBulkCopyWorkflowTasksRequest {
	r.workflowTasksBulkCopyRequest = &workflowTasksBulkCopyRequest
	return r
}

func (r ApiBulkCopyWorkflowTasksRequest) Execute() (*AsyncTaskLink, *http.Response, error) {
	return r.ApiService.BulkCopyWorkflowTasksExecute(r)
}

/*
BulkCopyWorkflowTasks Bulk creates new workflow tasks where each new task has the same fields and assignee as one of the provided tasks and creates a relationship between the provided task and its copy 

Bulk creates new workflow tasks based on the provided tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCopyWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) BulkCopyWorkflowTasks(ctx context.Context) ApiBulkCopyWorkflowTasksRequest {
	return ApiBulkCopyWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncTaskLink
func (a *WorkflowTasksApiService) BulkCopyWorkflowTasksExecute(r ApiBulkCopyWorkflowTasksRequest) (*AsyncTaskLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.BulkCopyWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks:bulk-copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTasksBulkCopyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTasksBulkCreateRequest *WorkflowTasksBulkCreateRequest
}

func (r ApiBulkCreateWorkflowTasksRequest) WorkflowTasksBulkCreateRequest(workflowTasksBulkCreateRequest WorkflowTasksBulkCreateRequest) ApiBulkCreateWorkflowTasksRequest {
	r.workflowTasksBulkCreateRequest = &workflowTasksBulkCreateRequest
	return r
}

func (r ApiBulkCreateWorkflowTasksRequest) Execute() (*AsyncTaskLink, *http.Response, error) {
	return r.ApiService.BulkCreateWorkflowTasksExecute(r)
}

/*
BulkCreateWorkflowTasks Create one or more workflow tasks

Create one or more workflow tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) BulkCreateWorkflowTasks(ctx context.Context) ApiBulkCreateWorkflowTasksRequest {
	return ApiBulkCreateWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncTaskLink
func (a *WorkflowTasksApiService) BulkCreateWorkflowTasksExecute(r ApiBulkCreateWorkflowTasksRequest) (*AsyncTaskLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.BulkCreateWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks:bulk-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTasksBulkCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUpdateWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTasksBulkUpdateRequest *WorkflowTasksBulkUpdateRequest
}

func (r ApiBulkUpdateWorkflowTasksRequest) WorkflowTasksBulkUpdateRequest(workflowTasksBulkUpdateRequest WorkflowTasksBulkUpdateRequest) ApiBulkUpdateWorkflowTasksRequest {
	r.workflowTasksBulkUpdateRequest = &workflowTasksBulkUpdateRequest
	return r
}

func (r ApiBulkUpdateWorkflowTasksRequest) Execute() (*AsyncTaskLink, *http.Response, error) {
	return r.ApiService.BulkUpdateWorkflowTasksExecute(r)
}

/*
BulkUpdateWorkflowTasks Update one or more workflow task

Update one or more workflow tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUpdateWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) BulkUpdateWorkflowTasks(ctx context.Context) ApiBulkUpdateWorkflowTasksRequest {
	return ApiBulkUpdateWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncTaskLink
func (a *WorkflowTasksApiService) BulkUpdateWorkflowTasksExecute(r ApiBulkUpdateWorkflowTasksRequest) (*AsyncTaskLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.BulkUpdateWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks:bulk-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTasksBulkUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyWorkflowTaskRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTaskId string
}

func (r ApiCopyWorkflowTaskRequest) Execute() (*WorkflowTask, *http.Response, error) {
	return r.ApiService.CopyWorkflowTaskExecute(r)
}

/*
CopyWorkflowTask Creates a new workflow task with the same fields and assignee as the provided task and creates a relationship between the two tasks 

Creates a new workflow task based on the provided task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowTaskId The ID of the workflow task
 @return ApiCopyWorkflowTaskRequest
*/
func (a *WorkflowTasksApiService) CopyWorkflowTask(ctx context.Context, workflowTaskId string) ApiCopyWorkflowTaskRequest {
	return ApiCopyWorkflowTaskRequest{
		ApiService: a,
		ctx: ctx,
		workflowTaskId: workflowTaskId,
	}
}

// Execute executes the request
//  @return WorkflowTask
func (a *WorkflowTasksApiService) CopyWorkflowTaskExecute(r ApiCopyWorkflowTaskRequest) (*WorkflowTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.CopyWorkflowTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks/{workflow_task_id}:copy"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_task_id"+"}", url.PathEscape(parameterToString(r.workflowTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWorkflowTaskRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTaskCreate *WorkflowTaskCreate
}

func (r ApiCreateWorkflowTaskRequest) WorkflowTaskCreate(workflowTaskCreate WorkflowTaskCreate) ApiCreateWorkflowTaskRequest {
	r.workflowTaskCreate = &workflowTaskCreate
	return r
}

func (r ApiCreateWorkflowTaskRequest) Execute() (*WorkflowTask, *http.Response, error) {
	return r.ApiService.CreateWorkflowTaskExecute(r)
}

/*
CreateWorkflowTask Create a new workflow task

Create a new workflow task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWorkflowTaskRequest
*/
func (a *WorkflowTasksApiService) CreateWorkflowTask(ctx context.Context) ApiCreateWorkflowTaskRequest {
	return ApiCreateWorkflowTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WorkflowTask
func (a *WorkflowTasksApiService) CreateWorkflowTaskExecute(r ApiCreateWorkflowTaskRequest) (*WorkflowTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.CreateWorkflowTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTaskCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkflowTaskRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTaskId string
}

func (r ApiGetWorkflowTaskRequest) Execute() (*WorkflowTask, *http.Response, error) {
	return r.ApiService.GetWorkflowTaskExecute(r)
}

/*
GetWorkflowTask Get a workflow task

Get a workflow task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowTaskId The ID of the workflow task
 @return ApiGetWorkflowTaskRequest
*/
func (a *WorkflowTasksApiService) GetWorkflowTask(ctx context.Context, workflowTaskId string) ApiGetWorkflowTaskRequest {
	return ApiGetWorkflowTaskRequest{
		ApiService: a,
		ctx: ctx,
		workflowTaskId: workflowTaskId,
	}
}

// Execute executes the request
//  @return WorkflowTask
func (a *WorkflowTasksApiService) GetWorkflowTaskExecute(r ApiGetWorkflowTaskRequest) (*WorkflowTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.GetWorkflowTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks/{workflow_task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_task_id"+"}", url.PathEscape(parameterToString(r.workflowTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	ids *string
	workflowTaskGroupIds *string
	schemaId *string
	statusIds *string
	assigneeIds *string
	watcherIds *string
	responsibleTeamIds *string
	executionOriginIds *string
	executionTypes *string
	linkedItemIdsAnyOf *string
	linkedItemIdsAllOf *string
	linkedItemIdsNoneOf *string
	schemaFields *map[string]interface{}
	name *string
	nameIncludes *string
	creatorIds *string
	scheduledOn *ListWorkflowTasksScheduledOnParameter
	scheduledOnLt *string
	scheduledOnLte *string
	scheduledOnGte *string
	scheduledOnGt *string
	modifiedAt *string
	nextToken *string
	pageSize *int32
	displayIds *string
	archiveReason *string
}

// Comma separated list of workflow task IDs
func (r ApiListWorkflowTasksRequest) Ids(ids string) ApiListWorkflowTasksRequest {
	r.ids = &ids
	return r
}

// Comma separated list of workflow IDs
func (r ApiListWorkflowTasksRequest) WorkflowTaskGroupIds(workflowTaskGroupIds string) ApiListWorkflowTasksRequest {
	r.workflowTaskGroupIds = &workflowTaskGroupIds
	return r
}

// The ID of the workflow task schema of the workflow task
func (r ApiListWorkflowTasksRequest) SchemaId(schemaId string) ApiListWorkflowTasksRequest {
	r.schemaId = &schemaId
	return r
}

// Comma separated list of workflow task status ids
func (r ApiListWorkflowTasksRequest) StatusIds(statusIds string) ApiListWorkflowTasksRequest {
	r.statusIds = &statusIds
	return r
}

// Comma separated list of user ids or \&quot;null\&quot;
func (r ApiListWorkflowTasksRequest) AssigneeIds(assigneeIds string) ApiListWorkflowTasksRequest {
	r.assigneeIds = &assigneeIds
	return r
}

// Comma separated list of user IDs or \&quot;null\&quot;
func (r ApiListWorkflowTasksRequest) WatcherIds(watcherIds string) ApiListWorkflowTasksRequest {
	r.watcherIds = &watcherIds
	return r
}

// Comma separated list of team IDs or \&quot;null\&quot;
func (r ApiListWorkflowTasksRequest) ResponsibleTeamIds(responsibleTeamIds string) ApiListWorkflowTasksRequest {
	r.responsibleTeamIds = &responsibleTeamIds
	return r
}

// Comma separated list of entry IDs
func (r ApiListWorkflowTasksRequest) ExecutionOriginIds(executionOriginIds string) ApiListWorkflowTasksRequest {
	r.executionOriginIds = &executionOriginIds
	return r
}

// Comma separated list of workflow execution types. Acceptable execution types are \&quot;DIRECT\&quot; and \&quot;ENTRY\&quot; 
func (r ApiListWorkflowTasksRequest) ExecutionTypes(executionTypes string) ApiListWorkflowTasksRequest {
	r.executionTypes = &executionTypes
	return r
}

// Comma separated list of bioentity or storable IDs. Returns workflow tasks where the task&#39;s schema fields reference at least one of the provided items. 
func (r ApiListWorkflowTasksRequest) LinkedItemIdsAnyOf(linkedItemIdsAnyOf string) ApiListWorkflowTasksRequest {
	r.linkedItemIdsAnyOf = &linkedItemIdsAnyOf
	return r
}

// Comma separated list of bioentity or storable IDs. Returns workflow tasks where the task&#39;s schema fields reference all of the provided items. 
func (r ApiListWorkflowTasksRequest) LinkedItemIdsAllOf(linkedItemIdsAllOf string) ApiListWorkflowTasksRequest {
	r.linkedItemIdsAllOf = &linkedItemIdsAllOf
	return r
}

// Comma separated list of bioentity or storable IDs. Returns workflow tasks where the task&#39;s schema fields do not reference any of the provided items. 
func (r ApiListWorkflowTasksRequest) LinkedItemIdsNoneOf(linkedItemIdsNoneOf string) ApiListWorkflowTasksRequest {
	r.linkedItemIdsNoneOf = &linkedItemIdsNoneOf
	return r
}

// Schema field value. For Integer, Float, and Date type fields, supports the &gt;&#x3D; and &lt;&#x3D; operators. If present, the schemaId param must also be present. Restricts results to those with a field of whose value matches the filter. 
func (r ApiListWorkflowTasksRequest) SchemaFields(schemaFields map[string]interface{}) ApiListWorkflowTasksRequest {
	r.schemaFields = &schemaFields
	return r
}

// The name of the workflow task
func (r ApiListWorkflowTasksRequest) Name(name string) ApiListWorkflowTasksRequest {
	r.name = &name
	return r
}

// Part of the name of the workflow task
func (r ApiListWorkflowTasksRequest) NameIncludes(nameIncludes string) ApiListWorkflowTasksRequest {
	r.nameIncludes = &nameIncludes
	return r
}

// Comma separated list of user IDs.
func (r ApiListWorkflowTasksRequest) CreatorIds(creatorIds string) ApiListWorkflowTasksRequest {
	r.creatorIds = &creatorIds
	return r
}

// The date on which the task was scheduled to be executed. Returns tasks which are scheduled on the provided date. If \&quot;null\&quot; is provided returns tasks which are unshceduled. 
func (r ApiListWorkflowTasksRequest) ScheduledOn(scheduledOn ListWorkflowTasksScheduledOnParameter) ApiListWorkflowTasksRequest {
	r.scheduledOn = &scheduledOn
	return r
}

// The date on which the task was scheduled to be executed. Returns tasks which are scheduled before the provided date. 
func (r ApiListWorkflowTasksRequest) ScheduledOnLt(scheduledOnLt string) ApiListWorkflowTasksRequest {
	r.scheduledOnLt = &scheduledOnLt
	return r
}

// The date on which the task was scheduled to be executed. Returns tasks which are scheduled before or on the provided date. 
func (r ApiListWorkflowTasksRequest) ScheduledOnLte(scheduledOnLte string) ApiListWorkflowTasksRequest {
	r.scheduledOnLte = &scheduledOnLte
	return r
}

// The date on which the task was scheduled to be executed. Returns tasks which are scheduled on or after the provided date. 
func (r ApiListWorkflowTasksRequest) ScheduledOnGte(scheduledOnGte string) ApiListWorkflowTasksRequest {
	r.scheduledOnGte = &scheduledOnGte
	return r
}

// The date on which the task was scheduled to be executed. Returns tasks which are scheduled after the provided date. 
func (r ApiListWorkflowTasksRequest) ScheduledOnGt(scheduledOnGt string) ApiListWorkflowTasksRequest {
	r.scheduledOnGt = &scheduledOnGt
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListWorkflowTasksRequest) ModifiedAt(modifiedAt string) ApiListWorkflowTasksRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiListWorkflowTasksRequest) NextToken(nextToken string) ApiListWorkflowTasksRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListWorkflowTasksRequest) PageSize(pageSize int32) ApiListWorkflowTasksRequest {
	r.pageSize = &pageSize
	return r
}

// Comma-separated list of Workflow Task Display IDs.
func (r ApiListWorkflowTasksRequest) DisplayIds(displayIds string) ApiListWorkflowTasksRequest {
	r.displayIds = &displayIds
	return r
}

// Archive reason. Restricts items to those with the specified archive reason. Use \&quot;NOT_ARCHIVED\&quot; to filter for unarchived workflow tasks. Use \&quot;ANY_ARCHIVED\&quot; to filter for archived workflow tasks regardless of reason. Use \&quot;ANY_ARCHIVED_OR_NOT_ARCHIVED\&quot; to return items for both archived and unarchived. 
func (r ApiListWorkflowTasksRequest) ArchiveReason(archiveReason string) ApiListWorkflowTasksRequest {
	r.archiveReason = &archiveReason
	return r
}

func (r ApiListWorkflowTasksRequest) Execute() (*WorkflowTasksPaginatedList, *http.Response, error) {
	return r.ApiService.ListWorkflowTasksExecute(r)
}

/*
ListWorkflowTasks List workflow tasks

List workflow tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) ListWorkflowTasks(ctx context.Context) ApiListWorkflowTasksRequest {
	return ApiListWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WorkflowTasksPaginatedList
func (a *WorkflowTasksApiService) ListWorkflowTasksExecute(r ApiListWorkflowTasksRequest) (*WorkflowTasksPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTasksPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.ListWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.workflowTaskGroupIds != nil {
		localVarQueryParams.Add("workflowTaskGroupIds", parameterToString(*r.workflowTaskGroupIds, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.statusIds != nil {
		localVarQueryParams.Add("statusIds", parameterToString(*r.statusIds, ""))
	}
	if r.assigneeIds != nil {
		localVarQueryParams.Add("assigneeIds", parameterToString(*r.assigneeIds, ""))
	}
	if r.watcherIds != nil {
		localVarQueryParams.Add("watcherIds", parameterToString(*r.watcherIds, ""))
	}
	if r.responsibleTeamIds != nil {
		localVarQueryParams.Add("responsibleTeamIds", parameterToString(*r.responsibleTeamIds, ""))
	}
	if r.executionOriginIds != nil {
		localVarQueryParams.Add("executionOriginIds", parameterToString(*r.executionOriginIds, ""))
	}
	if r.executionTypes != nil {
		localVarQueryParams.Add("executionTypes", parameterToString(*r.executionTypes, ""))
	}
	if r.linkedItemIdsAnyOf != nil {
		localVarQueryParams.Add("linkedItemIds.anyOf", parameterToString(*r.linkedItemIdsAnyOf, ""))
	}
	if r.linkedItemIdsAllOf != nil {
		localVarQueryParams.Add("linkedItemIds.allOf", parameterToString(*r.linkedItemIdsAllOf, ""))
	}
	if r.linkedItemIdsNoneOf != nil {
		localVarQueryParams.Add("linkedItemIds.noneOf", parameterToString(*r.linkedItemIdsNoneOf, ""))
	}
	if r.schemaFields != nil {
		localVarQueryParams.Add("schemaFields", parameterToString(*r.schemaFields, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIncludes != nil {
		localVarQueryParams.Add("nameIncludes", parameterToString(*r.nameIncludes, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creatorIds", parameterToString(*r.creatorIds, ""))
	}
	if r.scheduledOn != nil {
		localVarQueryParams.Add("scheduledOn", parameterToString(*r.scheduledOn, ""))
	}
	if r.scheduledOnLt != nil {
		localVarQueryParams.Add("scheduledOn.lt", parameterToString(*r.scheduledOnLt, ""))
	}
	if r.scheduledOnLte != nil {
		localVarQueryParams.Add("scheduledOn.lte", parameterToString(*r.scheduledOnLte, ""))
	}
	if r.scheduledOnGte != nil {
		localVarQueryParams.Add("scheduledOn.gte", parameterToString(*r.scheduledOnGte, ""))
	}
	if r.scheduledOnGt != nil {
		localVarQueryParams.Add("scheduledOn.gt", parameterToString(*r.scheduledOnGt, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.displayIds != nil {
		localVarQueryParams.Add("displayIds", parameterToString(*r.displayIds, ""))
	}
	if r.archiveReason != nil {
		localVarQueryParams.Add("archiveReason", parameterToString(*r.archiveReason, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveWorkflowTasksRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTasksUnarchive *WorkflowTasksUnarchive
}

func (r ApiUnarchiveWorkflowTasksRequest) WorkflowTasksUnarchive(workflowTasksUnarchive WorkflowTasksUnarchive) ApiUnarchiveWorkflowTasksRequest {
	r.workflowTasksUnarchive = &workflowTasksUnarchive
	return r
}

func (r ApiUnarchiveWorkflowTasksRequest) Execute() (*WorkflowTasksArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchiveWorkflowTasksExecute(r)
}

/*
UnarchiveWorkflowTasks Unarchive one or more workflow tasks

Unarchive one or more workflow tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveWorkflowTasksRequest
*/
func (a *WorkflowTasksApiService) UnarchiveWorkflowTasks(ctx context.Context) ApiUnarchiveWorkflowTasksRequest {
	return ApiUnarchiveWorkflowTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WorkflowTasksArchivalChange
func (a *WorkflowTasksApiService) UnarchiveWorkflowTasksExecute(r ApiUnarchiveWorkflowTasksRequest) (*WorkflowTasksArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTasksArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.UnarchiveWorkflowTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTasksUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWorkflowTaskRequest struct {
	ctx context.Context
	ApiService *WorkflowTasksApiService
	workflowTaskId string
	workflowTaskUpdate *WorkflowTaskUpdate
}

func (r ApiUpdateWorkflowTaskRequest) WorkflowTaskUpdate(workflowTaskUpdate WorkflowTaskUpdate) ApiUpdateWorkflowTaskRequest {
	r.workflowTaskUpdate = &workflowTaskUpdate
	return r
}

func (r ApiUpdateWorkflowTaskRequest) Execute() (*WorkflowTask, *http.Response, error) {
	return r.ApiService.UpdateWorkflowTaskExecute(r)
}

/*
UpdateWorkflowTask Update a workflow task

Update a workflow task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowTaskId The ID of the workflow task
 @return ApiUpdateWorkflowTaskRequest
*/
func (a *WorkflowTasksApiService) UpdateWorkflowTask(ctx context.Context, workflowTaskId string) ApiUpdateWorkflowTaskRequest {
	return ApiUpdateWorkflowTaskRequest{
		ApiService: a,
		ctx: ctx,
		workflowTaskId: workflowTaskId,
	}
}

// Execute executes the request
//  @return WorkflowTask
func (a *WorkflowTasksApiService) UpdateWorkflowTaskExecute(r ApiUpdateWorkflowTaskRequest) (*WorkflowTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowTasksApiService.UpdateWorkflowTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow-tasks/{workflow_task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_task_id"+"}", url.PathEscape(parameterToString(r.workflowTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowTaskUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
