/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MixturesApiService MixturesApi service
type MixturesApiService service

type ApiArchiveMixturesRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixturesArchive *MixturesArchive
}

func (r ApiArchiveMixturesRequest) MixturesArchive(mixturesArchive MixturesArchive) ApiArchiveMixturesRequest {
	r.mixturesArchive = &mixturesArchive
	return r
}

func (r ApiArchiveMixturesRequest) Execute() (*MixturesArchivalChange, *http.Response, error) {
	return r.ApiService.ArchiveMixturesExecute(r)
}

/*
ArchiveMixtures Archive mixtures

Archive mixtures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveMixturesRequest
*/
func (a *MixturesApiService) ArchiveMixtures(ctx context.Context) ApiArchiveMixturesRequest {
	return ApiArchiveMixturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MixturesArchivalChange
func (a *MixturesApiService) ArchiveMixturesExecute(r ApiArchiveMixturesRequest) (*MixturesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MixturesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.ArchiveMixtures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixturesArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateMixturesRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixturesBulkCreateRequest *MixturesBulkCreateRequest
}

func (r ApiBulkCreateMixturesRequest) MixturesBulkCreateRequest(mixturesBulkCreateRequest MixturesBulkCreateRequest) ApiBulkCreateMixturesRequest {
	r.mixturesBulkCreateRequest = &mixturesBulkCreateRequest
	return r
}

func (r ApiBulkCreateMixturesRequest) Execute() (*AsyncTaskLink, *http.Response, error) {
	return r.ApiService.BulkCreateMixturesExecute(r)
}

/*
BulkCreateMixtures Bulk Create mixtures

Create multiple mixtures. Limit of 1000 mixtures per request.
To create new child mixtures (eg. a prep) from parent mixtures (eg. a recipe), set the parent mixture field and specify the desired final state for your ingredients.
Benchling will recognize that any ingredients you specify that match ingredients on the parent mixtures (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateMixturesRequest
*/
func (a *MixturesApiService) BulkCreateMixtures(ctx context.Context) ApiBulkCreateMixturesRequest {
	return ApiBulkCreateMixturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncTaskLink
func (a *MixturesApiService) BulkCreateMixturesExecute(r ApiBulkCreateMixturesRequest) (*AsyncTaskLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.BulkCreateMixtures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures:bulk-create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixturesBulkCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUpdateMixturesRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixturesBulkUpdateRequest *MixturesBulkUpdateRequest
}

func (r ApiBulkUpdateMixturesRequest) MixturesBulkUpdateRequest(mixturesBulkUpdateRequest MixturesBulkUpdateRequest) ApiBulkUpdateMixturesRequest {
	r.mixturesBulkUpdateRequest = &mixturesBulkUpdateRequest
	return r
}

func (r ApiBulkUpdateMixturesRequest) Execute() (*AsyncTaskLink, *http.Response, error) {
	return r.ApiService.BulkUpdateMixturesExecute(r)
}

/*
BulkUpdateMixtures Bulk Update mixtures

Update multiple mixtures.
To change the parent mixture on your specified mixtures, set the parent mixture field and specify the desired final state for your ingredients.
Benchling will recognize that any ingredients you specify that match ingredients on the parent mixtures (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUpdateMixturesRequest
*/
func (a *MixturesApiService) BulkUpdateMixtures(ctx context.Context) ApiBulkUpdateMixturesRequest {
	return ApiBulkUpdateMixturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncTaskLink
func (a *MixturesApiService) BulkUpdateMixturesExecute(r ApiBulkUpdateMixturesRequest) (*AsyncTaskLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.BulkUpdateMixtures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures:bulk-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixturesBulkUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMixtureRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixtureCreate *MixtureCreate
}

func (r ApiCreateMixtureRequest) MixtureCreate(mixtureCreate MixtureCreate) ApiCreateMixtureRequest {
	r.mixtureCreate = &mixtureCreate
	return r
}

func (r ApiCreateMixtureRequest) Execute() (*Mixture, *http.Response, error) {
	return r.ApiService.CreateMixtureExecute(r)
}

/*
CreateMixture Create a mixture

Create a mixture.
To create a new child mixture (eg. a prep) from a parent mixture (eg. a recipe), set the parent mixture field and specify the desired final state for your ingredients.
Benchling will recognize that any ingredients you specify that match ingredients on the parent mixture (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMixtureRequest
*/
func (a *MixturesApiService) CreateMixture(ctx context.Context) ApiCreateMixtureRequest {
	return ApiCreateMixtureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Mixture
func (a *MixturesApiService) CreateMixtureExecute(r ApiCreateMixtureRequest) (*Mixture, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Mixture
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.CreateMixture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixtureCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMixtureRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixtureId string
}

func (r ApiGetMixtureRequest) Execute() (*Mixture, *http.Response, error) {
	return r.ApiService.GetMixtureExecute(r)
}

/*
GetMixture Get a mixture

Get a mixture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mixtureId
 @return ApiGetMixtureRequest
*/
func (a *MixturesApiService) GetMixture(ctx context.Context, mixtureId string) ApiGetMixtureRequest {
	return ApiGetMixtureRequest{
		ApiService: a,
		ctx: ctx,
		mixtureId: mixtureId,
	}
}

// Execute executes the request
//  @return Mixture
func (a *MixturesApiService) GetMixtureExecute(r ApiGetMixtureRequest) (*Mixture, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Mixture
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.GetMixture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures/{mixture_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"mixture_id"+"}", url.PathEscape(parameterToString(r.mixtureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMixturesRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	nextToken *string
	pageSize *int32
	sort *string
	modifiedAt *string
	name *string
	nameIncludes *string
	folderId *string
	mentionedIn *string
	projectId *string
	registryId *string
	schemaId *string
	schemaFields *map[string]interface{}
	archiveReason *string
	mentions *string
	ids *string
	namesAnyOf *string
	namesAnyOfCaseSensitive *string
	entityRegistryIdsAnyOf *string
	ingredientComponentEntityIds *string
	ingredientComponentEntityIdsAnyOf *string
	authorIdsAnyOf *string
}

func (r ApiListMixturesRequest) NextToken(nextToken string) ApiListMixturesRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListMixturesRequest) PageSize(pageSize int32) ApiListMixturesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListMixturesRequest) Sort(sort string) ApiListMixturesRequest {
	r.sort = &sort
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListMixturesRequest) ModifiedAt(modifiedAt string) ApiListMixturesRequest {
	r.modifiedAt = &modifiedAt
	return r
}

// Name of a mixture. Restricts results to those with the specified name, alias, or entity registry ID.
func (r ApiListMixturesRequest) Name(name string) ApiListMixturesRequest {
	r.name = &name
	return r
}

// Name substring of a mixture. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring. 
func (r ApiListMixturesRequest) NameIncludes(nameIncludes string) ApiListMixturesRequest {
	r.nameIncludes = &nameIncludes
	return r
}

// ID of a folder. Restricts results to those in the folder.
func (r ApiListMixturesRequest) FolderId(folderId string) ApiListMixturesRequest {
	r.folderId = &folderId
	return r
}

// Comma-separated list of entry IDs. Restricts results to mixtures mentioned in those entries. 
func (r ApiListMixturesRequest) MentionedIn(mentionedIn string) ApiListMixturesRequest {
	r.mentionedIn = &mentionedIn
	return r
}

// ID of a project. Restricts results to those in the project.
func (r ApiListMixturesRequest) ProjectId(projectId string) ApiListMixturesRequest {
	r.projectId = &projectId
	return r
}

// ID of a registry. Restricts results to those registered in this registry. Specifying \&quot;null\&quot; returns unregistered items. 
func (r ApiListMixturesRequest) RegistryId(registryId string) ApiListMixturesRequest {
	r.registryId = &registryId
	return r
}

// ID of a schema. Restricts results to those of the specified schema. 
func (r ApiListMixturesRequest) SchemaId(schemaId string) ApiListMixturesRequest {
	r.schemaId = &schemaId
	return r
}

// Schema field value. For Integer, Float, and Date type fields, supports the &gt;&#x3D; and &lt;&#x3D; operators. If present, the schemaId param must also be present. Restricts results to those with a field of whose value matches the filter. 
func (r ApiListMixturesRequest) SchemaFields(schemaFields map[string]interface{}) ApiListMixturesRequest {
	r.schemaFields = &schemaFields
	return r
}

// Archive reason. Restricts items to those with the specified archive reason. Use \&quot;NOT_ARCHIVED\&quot; to filter for unarchived mixtures. Use \&quot;ANY_ARCHIVED\&quot; to filter for archived mixtures regardless of reason. Use \&quot;ANY_ARCHIVED_OR_NOT_ARCHIVED\&quot; to return items for both archived and unarchived. 
func (r ApiListMixturesRequest) ArchiveReason(archiveReason string) ApiListMixturesRequest {
	r.archiveReason = &archiveReason
	return r
}

// Comma-separated list of resource IDs. Restricts results to those that mention the given items in the description. 
func (r ApiListMixturesRequest) Mentions(mentions string) ApiListMixturesRequest {
	r.mentions = &mentions
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListMixturesRequest) Ids(ids string) ApiListMixturesRequest {
	r.ids = &ids
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity. 
func (r ApiListMixturesRequest) NamesAnyOf(namesAnyOf string) ApiListMixturesRequest {
	r.namesAnyOf = &namesAnyOf
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive. 
func (r ApiListMixturesRequest) NamesAnyOfCaseSensitive(namesAnyOfCaseSensitive string) ApiListMixturesRequest {
	r.namesAnyOfCaseSensitive = &namesAnyOfCaseSensitive
	return r
}

// Comma-separated list of entity registry IDs. Restricts results to those that match any of the specified registry IDs. 
func (r ApiListMixturesRequest) EntityRegistryIdsAnyOf(entityRegistryIdsAnyOf string) ApiListMixturesRequest {
	r.entityRegistryIdsAnyOf = &entityRegistryIdsAnyOf
	return r
}

// Comma-separated list of ingredient component entity ids. Matches all mixtures that contain ingredients whose component entities match all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListMixturesRequest) IngredientComponentEntityIds(ingredientComponentEntityIds string) ApiListMixturesRequest {
	r.ingredientComponentEntityIds = &ingredientComponentEntityIds
	return r
}

// Comma-separated list of ingredient component entity ids. Matches all mixtures that contain ingredients whose component entities match any of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListMixturesRequest) IngredientComponentEntityIdsAnyOf(ingredientComponentEntityIdsAnyOf string) ApiListMixturesRequest {
	r.ingredientComponentEntityIdsAnyOf = &ingredientComponentEntityIdsAnyOf
	return r
}

// Comma separated list of user or app IDs
func (r ApiListMixturesRequest) AuthorIdsAnyOf(authorIdsAnyOf string) ApiListMixturesRequest {
	r.authorIdsAnyOf = &authorIdsAnyOf
	return r
}

func (r ApiListMixturesRequest) Execute() (*MixturesPaginatedList, *http.Response, error) {
	return r.ApiService.ListMixturesExecute(r)
}

/*
ListMixtures List mixtures

List mixtures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMixturesRequest
*/
func (a *MixturesApiService) ListMixtures(ctx context.Context) ApiListMixturesRequest {
	return ApiListMixturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MixturesPaginatedList
func (a *MixturesApiService) ListMixturesExecute(r ApiListMixturesRequest) (*MixturesPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MixturesPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.ListMixtures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIncludes != nil {
		localVarQueryParams.Add("nameIncludes", parameterToString(*r.nameIncludes, ""))
	}
	if r.folderId != nil {
		localVarQueryParams.Add("folderId", parameterToString(*r.folderId, ""))
	}
	if r.mentionedIn != nil {
		localVarQueryParams.Add("mentionedIn", parameterToString(*r.mentionedIn, ""))
	}
	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.registryId != nil {
		localVarQueryParams.Add("registryId", parameterToString(*r.registryId, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.schemaFields != nil {
		localVarQueryParams.Add("schemaFields", parameterToString(*r.schemaFields, ""))
	}
	if r.archiveReason != nil {
		localVarQueryParams.Add("archiveReason", parameterToString(*r.archiveReason, ""))
	}
	if r.mentions != nil {
		localVarQueryParams.Add("mentions", parameterToString(*r.mentions, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.namesAnyOf != nil {
		localVarQueryParams.Add("names.anyOf", parameterToString(*r.namesAnyOf, ""))
	}
	if r.namesAnyOfCaseSensitive != nil {
		localVarQueryParams.Add("names.anyOf.caseSensitive", parameterToString(*r.namesAnyOfCaseSensitive, ""))
	}
	if r.entityRegistryIdsAnyOf != nil {
		localVarQueryParams.Add("entityRegistryIds.anyOf", parameterToString(*r.entityRegistryIdsAnyOf, ""))
	}
	if r.ingredientComponentEntityIds != nil {
		localVarQueryParams.Add("ingredientComponentEntityIds", parameterToString(*r.ingredientComponentEntityIds, ""))
	}
	if r.ingredientComponentEntityIdsAnyOf != nil {
		localVarQueryParams.Add("ingredientComponentEntityIds.anyOf", parameterToString(*r.ingredientComponentEntityIdsAnyOf, ""))
	}
	if r.authorIdsAnyOf != nil {
		localVarQueryParams.Add("authorIds.anyOf", parameterToString(*r.authorIdsAnyOf, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveMixturesRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixturesUnarchive *MixturesUnarchive
}

func (r ApiUnarchiveMixturesRequest) MixturesUnarchive(mixturesUnarchive MixturesUnarchive) ApiUnarchiveMixturesRequest {
	r.mixturesUnarchive = &mixturesUnarchive
	return r
}

func (r ApiUnarchiveMixturesRequest) Execute() (*MixturesArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchiveMixturesExecute(r)
}

/*
UnarchiveMixtures Unarchive mixtures

Unarchive mixtures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveMixturesRequest
*/
func (a *MixturesApiService) UnarchiveMixtures(ctx context.Context) ApiUnarchiveMixturesRequest {
	return ApiUnarchiveMixturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MixturesArchivalChange
func (a *MixturesApiService) UnarchiveMixturesExecute(r ApiUnarchiveMixturesRequest) (*MixturesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MixturesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.UnarchiveMixtures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixturesUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMixtureRequest struct {
	ctx context.Context
	ApiService *MixturesApiService
	mixtureId string
	mixtureUpdate *MixtureUpdate
}

func (r ApiUpdateMixtureRequest) MixtureUpdate(mixtureUpdate MixtureUpdate) ApiUpdateMixtureRequest {
	r.mixtureUpdate = &mixtureUpdate
	return r
}

func (r ApiUpdateMixtureRequest) Execute() (*Mixture, *http.Response, error) {
	return r.ApiService.UpdateMixtureExecute(r)
}

/*
UpdateMixture Update a mixture

Update a mixture.
To change the parent mixture, set the parent mixture field and specify the desired final state for your ingredients.
Benchling will recognize that any ingredients you specify that match ingredients on the parent mixture (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mixtureId
 @return ApiUpdateMixtureRequest
*/
func (a *MixturesApiService) UpdateMixture(ctx context.Context, mixtureId string) ApiUpdateMixtureRequest {
	return ApiUpdateMixtureRequest{
		ApiService: a,
		ctx: ctx,
		mixtureId: mixtureId,
	}
}

// Execute executes the request
//  @return Mixture
func (a *MixturesApiService) UpdateMixtureExecute(r ApiUpdateMixtureRequest) (*Mixture, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Mixture
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MixturesApiService.UpdateMixture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mixtures/{mixture_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"mixture_id"+"}", url.PathEscape(parameterToString(r.mixtureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mixtureUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
