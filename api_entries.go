/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// EntriesApiService EntriesApi service
type EntriesApiService service

type ApiArchiveEntriesRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entriesArchive *EntriesArchive
}

func (r ApiArchiveEntriesRequest) EntriesArchive(entriesArchive EntriesArchive) ApiArchiveEntriesRequest {
	r.entriesArchive = &entriesArchive
	return r
}

func (r ApiArchiveEntriesRequest) Execute() (*EntriesArchivalChange, *http.Response, error) {
	return r.ApiService.ArchiveEntriesExecute(r)
}

/*
ArchiveEntries Archive notebook entries

Archive notebook entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveEntriesRequest
*/
func (a *EntriesApiService) ArchiveEntries(ctx context.Context) ApiArchiveEntriesRequest {
	return ApiArchiveEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntriesArchivalChange
func (a *EntriesApiService) ArchiveEntriesExecute(r ApiArchiveEntriesRequest) (*EntriesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntriesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.ArchiveEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entriesArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetEntriesRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryIds *string
	displayIds *string
}

// Comma-separated list of Entry IDs.
func (r ApiBulkGetEntriesRequest) EntryIds(entryIds string) ApiBulkGetEntriesRequest {
	r.entryIds = &entryIds
	return r
}

// Comma-separated list of Entry Display IDs.
func (r ApiBulkGetEntriesRequest) DisplayIds(displayIds string) ApiBulkGetEntriesRequest {
	r.displayIds = &displayIds
	return r
}

func (r ApiBulkGetEntriesRequest) Execute() (*Entries, *http.Response, error) {
	return r.ApiService.BulkGetEntriesExecute(r)
}

/*
BulkGetEntries Get notebook entries using entry IDs or display IDs

Get notebook entries using entry IDs or display IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetEntriesRequest
*/
func (a *EntriesApiService) BulkGetEntries(ctx context.Context) ApiBulkGetEntriesRequest {
	return ApiBulkGetEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Entries
func (a *EntriesApiService) BulkGetEntriesExecute(r ApiBulkGetEntriesRequest) (*Entries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Entries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.BulkGetEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries:bulk-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.entryIds != nil {
		localVarQueryParams.Add("entryIds", parameterToString(*r.entryIds, ""))
	}
	if r.displayIds != nil {
		localVarQueryParams.Add("displayIds", parameterToString(*r.displayIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEntryRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryCreate *EntryCreate
}

func (r ApiCreateEntryRequest) EntryCreate(entryCreate EntryCreate) ApiCreateEntryRequest {
	r.entryCreate = &entryCreate
	return r
}

func (r ApiCreateEntryRequest) Execute() (*Entry, *http.Response, error) {
	return r.ApiService.CreateEntryExecute(r)
}

/*
CreateEntry Create a notebook entry

Create a notebook entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEntryRequest
*/
func (a *EntriesApiService) CreateEntry(ctx context.Context) ApiCreateEntryRequest {
	return ApiCreateEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Entry
func (a *EntriesApiService) CreateEntryExecute(r ApiCreateEntryRequest) (*Entry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Entry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.CreateEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entryCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntryRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryId string
}

func (r ApiGetEntryRequest) Execute() (*EntryById, *http.Response, error) {
	return r.ApiService.GetEntryExecute(r)
}

/*
GetEntry Get a notebook entry by ID

Get a notebook entry by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId ID of the entry
 @return ApiGetEntryRequest
*/
func (a *EntriesApiService) GetEntry(ctx context.Context, entryId string) ApiGetEntryRequest {
	return ApiGetEntryRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return EntryById
func (a *EntriesApiService) GetEntryExecute(r ApiGetEntryRequest) (*EntryById, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntryById
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.GetEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntryTemplateRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryTemplateId string
}

func (r ApiGetEntryTemplateRequest) Execute() (*EntryTemplate, *http.Response, error) {
	return r.ApiService.GetEntryTemplateExecute(r)
}

/*
GetEntryTemplate Get a notebook template entry by ID

Get a notebook template entry by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryTemplateId ID of the entry template
 @return ApiGetEntryTemplateRequest
*/
func (a *EntriesApiService) GetEntryTemplate(ctx context.Context, entryTemplateId string) ApiGetEntryTemplateRequest {
	return ApiGetEntryTemplateRequest{
		ApiService: a,
		ctx: ctx,
		entryTemplateId: entryTemplateId,
	}
}

// Execute executes the request
//  @return EntryTemplate
func (a *EntriesApiService) GetEntryTemplateExecute(r ApiGetEntryTemplateRequest) (*EntryTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntryTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.GetEntryTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entry-templates/{entry_template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"entry_template_id"+"}", url.PathEscape(parameterToString(r.entryTemplateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalFileMetadataRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryId string
	externalFileId string
}

func (r ApiGetExternalFileMetadataRequest) Execute() (*EntryExternalFileById, *http.Response, error) {
	return r.ApiService.GetExternalFileMetadataExecute(r)
}

/*
GetExternalFileMetadata Retrieves the metadata for an external file. Use the 'downloadURL' to download the actual file. 

Retrieves the metadata for an external file. Use the 'downloadURL' to download the actual file. (Expand the schema view for details)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId ID of the entry the file was uploaded to
 @param externalFileId ID of the external file
 @return ApiGetExternalFileMetadataRequest
*/
func (a *EntriesApiService) GetExternalFileMetadata(ctx context.Context, entryId string, externalFileId string) ApiGetExternalFileMetadataRequest {
	return ApiGetExternalFileMetadataRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
		externalFileId: externalFileId,
	}
}

// Execute executes the request
//  @return EntryExternalFileById
func (a *EntriesApiService) GetExternalFileMetadataExecute(r ApiGetExternalFileMetadataRequest) (*EntryExternalFileById, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntryExternalFileById
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.GetExternalFileMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries/{entry_id}/external-files/{external_file_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external_file_id"+"}", url.PathEscape(parameterToString(r.externalFileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListEntriesRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	pageSize *int32
	nextToken *string
	sort *string
	modifiedAt *string
	name *string
	projectId *string
	archiveReason *string
	reviewStatus *string
	mentionedIn *string
	mentions *string
	ids *string
	schemaId *string
	namesAnyOf *string
	namesAnyOfCaseSensitive *string
	assignedReviewerIdsAnyOf *string
	creatorIds *string
	authorIdsAnyOf *string
	displayIds *string
}

// Number of results to return. Defaults to 50, maximum of 100.
func (r ApiListEntriesRequest) PageSize(pageSize int32) ApiListEntriesRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListEntriesRequest) NextToken(nextToken string) ApiListEntriesRequest {
	r.nextToken = &nextToken
	return r
}

// Method by which to order search results. Valid sorts are modifiedAt (modified time, most recent first) and name (entity name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order. 
func (r ApiListEntriesRequest) Sort(sort string) ApiListEntriesRequest {
	r.sort = &sort
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; operator. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListEntriesRequest) ModifiedAt(modifiedAt string) ApiListEntriesRequest {
	r.modifiedAt = &modifiedAt
	return r
}

// Name of an Entry. Restricts results to those with the specified name.
func (r ApiListEntriesRequest) Name(name string) ApiListEntriesRequest {
	r.name = &name
	return r
}

// ID of a project. Restricts results to those in the project.
func (r ApiListEntriesRequest) ProjectId(projectId string) ApiListEntriesRequest {
	r.projectId = &projectId
	return r
}

// Archive reason. Restricts items to those with the specified archive reason. Use \&quot;NOT_ARCHIVED\&quot; to filter for unarchived entries. Use \&quot;ANY_ARCHIVED\&quot; to filter for archived entries regardless of reason. Use \&quot;ANY_ARCHIVED_OR_NOT_ARCHIVED\&quot; to return items for both archived and unarchived. 
func (r ApiListEntriesRequest) ArchiveReason(archiveReason string) ApiListEntriesRequest {
	r.archiveReason = &archiveReason
	return r
}

// Restrict results to those with the given review status. Supported statuses: IN_PROGRESS, ACCEPTED, REJECTED, NEEDS_REVIEW, RETRACTED 
func (r ApiListEntriesRequest) ReviewStatus(reviewStatus string) ApiListEntriesRequest {
	r.reviewStatus = &reviewStatus
	return r
}

// Comma-separated list of entry IDs. Restricts results to those mentioned within the entries in this list. 
func (r ApiListEntriesRequest) MentionedIn(mentionedIn string) ApiListEntriesRequest {
	r.mentionedIn = &mentionedIn
	return r
}

// Comma-separated list of resource IDs. Restricts results to entries that mention the given items. 
func (r ApiListEntriesRequest) Mentions(mentions string) ApiListEntriesRequest {
	r.mentions = &mentions
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListEntriesRequest) Ids(ids string) ApiListEntriesRequest {
	r.ids = &ids
	return r
}

// ID of a schema. Restricts results to those of the specified schema. 
func (r ApiListEntriesRequest) SchemaId(schemaId string) ApiListEntriesRequest {
	r.schemaId = &schemaId
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity. 
func (r ApiListEntriesRequest) NamesAnyOf(namesAnyOf string) ApiListEntriesRequest {
	r.namesAnyOf = &namesAnyOf
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case sensitive. 
func (r ApiListEntriesRequest) NamesAnyOfCaseSensitive(namesAnyOfCaseSensitive string) ApiListEntriesRequest {
	r.namesAnyOfCaseSensitive = &namesAnyOfCaseSensitive
	return r
}

// Comma-separated list of ids. Restricts results to entries that have assignees of any of the specified ids.
func (r ApiListEntriesRequest) AssignedReviewerIdsAnyOf(assignedReviewerIdsAnyOf string) ApiListEntriesRequest {
	r.assignedReviewerIdsAnyOf = &assignedReviewerIdsAnyOf
	return r
}

// Comma separated list of users IDs
func (r ApiListEntriesRequest) CreatorIds(creatorIds string) ApiListEntriesRequest {
	r.creatorIds = &creatorIds
	return r
}

// Comma separated list of user or app IDs
func (r ApiListEntriesRequest) AuthorIdsAnyOf(authorIdsAnyOf string) ApiListEntriesRequest {
	r.authorIdsAnyOf = &authorIdsAnyOf
	return r
}

// Comma-separated list of Entry Display IDs.
func (r ApiListEntriesRequest) DisplayIds(displayIds string) ApiListEntriesRequest {
	r.displayIds = &displayIds
	return r
}

func (r ApiListEntriesRequest) Execute() (*EntriesPaginatedList, *http.Response, error) {
	return r.ApiService.ListEntriesExecute(r)
}

/*
ListEntries List entries

List notebook entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEntriesRequest
*/
func (a *EntriesApiService) ListEntries(ctx context.Context) ApiListEntriesRequest {
	return ApiListEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntriesPaginatedList
func (a *EntriesApiService) ListEntriesExecute(r ApiListEntriesRequest) (*EntriesPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntriesPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.ListEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.archiveReason != nil {
		localVarQueryParams.Add("archiveReason", parameterToString(*r.archiveReason, ""))
	}
	if r.reviewStatus != nil {
		localVarQueryParams.Add("reviewStatus", parameterToString(*r.reviewStatus, ""))
	}
	if r.mentionedIn != nil {
		localVarQueryParams.Add("mentionedIn", parameterToString(*r.mentionedIn, ""))
	}
	if r.mentions != nil {
		localVarQueryParams.Add("mentions", parameterToString(*r.mentions, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.namesAnyOf != nil {
		localVarQueryParams.Add("names.anyOf", parameterToString(*r.namesAnyOf, ""))
	}
	if r.namesAnyOfCaseSensitive != nil {
		localVarQueryParams.Add("names.anyOf.caseSensitive", parameterToString(*r.namesAnyOfCaseSensitive, ""))
	}
	if r.assignedReviewerIdsAnyOf != nil {
		localVarQueryParams.Add("assignedReviewerIds.anyOf", parameterToString(*r.assignedReviewerIdsAnyOf, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creatorIds", parameterToString(*r.creatorIds, ""))
	}
	if r.authorIdsAnyOf != nil {
		localVarQueryParams.Add("authorIds.anyOf", parameterToString(*r.authorIdsAnyOf, ""))
	}
	if r.displayIds != nil {
		localVarQueryParams.Add("displayIds", parameterToString(*r.displayIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListEntryTemplatesRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	pageSize *int32
	nextToken *string
	modifiedAt *string
	name *string
	templateCollectionId *string
	ids *string
	schemaId *string
}

// Number of results to return. Defaults to 50, maximum of 100.
func (r ApiListEntryTemplatesRequest) PageSize(pageSize int32) ApiListEntryTemplatesRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListEntryTemplatesRequest) NextToken(nextToken string) ApiListEntryTemplatesRequest {
	r.nextToken = &nextToken
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListEntryTemplatesRequest) ModifiedAt(modifiedAt string) ApiListEntryTemplatesRequest {
	r.modifiedAt = &modifiedAt
	return r
}

// Name of an Entry Template. Restricts results to those with the specified name.
func (r ApiListEntryTemplatesRequest) Name(name string) ApiListEntryTemplatesRequest {
	r.name = &name
	return r
}

// ID of a template collection. Resticts results to those in the template collection. 
func (r ApiListEntryTemplatesRequest) TemplateCollectionId(templateCollectionId string) ApiListEntryTemplatesRequest {
	r.templateCollectionId = &templateCollectionId
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListEntryTemplatesRequest) Ids(ids string) ApiListEntryTemplatesRequest {
	r.ids = &ids
	return r
}

// ID of a schema. Restricts results to those of the specified schema. 
func (r ApiListEntryTemplatesRequest) SchemaId(schemaId string) ApiListEntryTemplatesRequest {
	r.schemaId = &schemaId
	return r
}

func (r ApiListEntryTemplatesRequest) Execute() (*EntryTemplatesPaginatedList, *http.Response, error) {
	return r.ApiService.ListEntryTemplatesExecute(r)
}

/*
ListEntryTemplates List entry templates

List entry templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEntryTemplatesRequest
*/
func (a *EntriesApiService) ListEntryTemplates(ctx context.Context) ApiListEntryTemplatesRequest {
	return ApiListEntryTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntryTemplatesPaginatedList
func (a *EntriesApiService) ListEntryTemplatesExecute(r ApiListEntryTemplatesRequest) (*EntryTemplatesPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntryTemplatesPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.ListEntryTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entry-templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.templateCollectionId != nil {
		localVarQueryParams.Add("templateCollectionId", parameterToString(*r.templateCollectionId, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveEntriesRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entriesUnarchive *EntriesUnarchive
}

func (r ApiUnarchiveEntriesRequest) EntriesUnarchive(entriesUnarchive EntriesUnarchive) ApiUnarchiveEntriesRequest {
	r.entriesUnarchive = &entriesUnarchive
	return r
}

func (r ApiUnarchiveEntriesRequest) Execute() (*EntriesArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchiveEntriesExecute(r)
}

/*
UnarchiveEntries Unarchive notebook entries

Unarchive notebook entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveEntriesRequest
*/
func (a *EntriesApiService) UnarchiveEntries(ctx context.Context) ApiUnarchiveEntriesRequest {
	return ApiUnarchiveEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntriesArchivalChange
func (a *EntriesApiService) UnarchiveEntriesExecute(r ApiUnarchiveEntriesRequest) (*EntriesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntriesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.UnarchiveEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entriesUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEntryRequest struct {
	ctx context.Context
	ApiService *EntriesApiService
	entryId string
	entryUpdate *EntryUpdate
}

func (r ApiUpdateEntryRequest) EntryUpdate(entryUpdate EntryUpdate) ApiUpdateEntryRequest {
	r.entryUpdate = &entryUpdate
	return r
}

func (r ApiUpdateEntryRequest) Execute() (*Entry, *http.Response, error) {
	return r.ApiService.UpdateEntryExecute(r)
}

/*
UpdateEntry Update a notebook entry's metadata

Update a notebook entry's metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entryId ID of the entry
 @return ApiUpdateEntryRequest
*/
func (a *EntriesApiService) UpdateEntry(ctx context.Context, entryId string) ApiUpdateEntryRequest {
	return ApiUpdateEntryRequest{
		ApiService: a,
		ctx: ctx,
		entryId: entryId,
	}
}

// Execute executes the request
//  @return Entry
func (a *EntriesApiService) UpdateEntryExecute(r ApiUpdateEntryRequest) (*Entry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Entry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntriesApiService.UpdateEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entries/{entry_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"entry_id"+"}", url.PathEscape(parameterToString(r.entryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entryUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
