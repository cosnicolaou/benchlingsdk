/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PlatesApiService PlatesApi service
type PlatesApiService service

type ApiArchivePlatesRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	platesArchive *PlatesArchive
}

func (r ApiArchivePlatesRequest) PlatesArchive(platesArchive PlatesArchive) ApiArchivePlatesRequest {
	r.platesArchive = &platesArchive
	return r
}

func (r ApiArchivePlatesRequest) Execute() (*PlatesArchivalChange, *http.Response, error) {
	return r.ApiService.ArchivePlatesExecute(r)
}

/*
ArchivePlates Archive plates

Archive plates and any containers of the plates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchivePlatesRequest
*/
func (a *PlatesApiService) ArchivePlates(ctx context.Context) ApiArchivePlatesRequest {
	return ApiArchivePlatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatesArchivalChange
func (a *PlatesApiService) ArchivePlatesExecute(r ApiArchivePlatesRequest) (*PlatesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.ArchivePlates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.platesArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetPlatesRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	plateIds *string
	barcodes *string
	returning *string
}

// Comma-separated list of plate IDs.
func (r ApiBulkGetPlatesRequest) PlateIds(plateIds string) ApiBulkGetPlatesRequest {
	r.plateIds = &plateIds
	return r
}

// Comma-separated list of plate barcodes.
func (r ApiBulkGetPlatesRequest) Barcodes(barcodes string) ApiBulkGetPlatesRequest {
	r.barcodes = &barcodes
	return r
}

// Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, &#39;*&#39;. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter). 
func (r ApiBulkGetPlatesRequest) Returning(returning string) ApiBulkGetPlatesRequest {
	r.returning = &returning
	return r
}

func (r ApiBulkGetPlatesRequest) Execute() (*PlatesBulkGet, *http.Response, error) {
	return r.ApiService.BulkGetPlatesExecute(r)
}

/*
BulkGetPlates BulkGet plates

BulkGet plates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetPlatesRequest
*/
func (a *PlatesApiService) BulkGetPlates(ctx context.Context) ApiBulkGetPlatesRequest {
	return ApiBulkGetPlatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatesBulkGet
func (a *PlatesApiService) BulkGetPlatesExecute(r ApiBulkGetPlatesRequest) (*PlatesBulkGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatesBulkGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.BulkGetPlates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates:bulk-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.plateIds != nil {
		localVarQueryParams.Add("plateIds", parameterToString(*r.plateIds, ""))
	}
	if r.barcodes != nil {
		localVarQueryParams.Add("barcodes", parameterToString(*r.barcodes, ""))
	}
	if r.returning != nil {
		localVarQueryParams.Add("returning", parameterToString(*r.returning, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePlateRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	returning *string
	plateCreate *PlateCreate
}

// Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, &#39;*&#39;. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter). 
func (r ApiCreatePlateRequest) Returning(returning string) ApiCreatePlateRequest {
	r.returning = &returning
	return r
}

func (r ApiCreatePlateRequest) PlateCreate(plateCreate PlateCreate) ApiCreatePlateRequest {
	r.plateCreate = &plateCreate
	return r
}

func (r ApiCreatePlateRequest) Execute() (*Plate, *http.Response, error) {
	return r.ApiService.CreatePlateExecute(r)
}

/*
CreatePlate Create a plate

Create a plate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePlateRequest
*/
func (a *PlatesApiService) CreatePlate(ctx context.Context) ApiCreatePlateRequest {
	return ApiCreatePlateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Plate
func (a *PlatesApiService) CreatePlateExecute(r ApiCreatePlateRequest) (*Plate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.CreatePlate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returning != nil {
		localVarQueryParams.Add("returning", parameterToString(*r.returning, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plateCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlateRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	plateId string
	returning *string
}

// Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, &#39;*&#39;. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter). 
func (r ApiGetPlateRequest) Returning(returning string) ApiGetPlateRequest {
	r.returning = &returning
	return r
}

func (r ApiGetPlateRequest) Execute() (*Plate, *http.Response, error) {
	return r.ApiService.GetPlateExecute(r)
}

/*
GetPlate Get a plate

Get a plate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plateId
 @return ApiGetPlateRequest
*/
func (a *PlatesApiService) GetPlate(ctx context.Context, plateId string) ApiGetPlateRequest {
	return ApiGetPlateRequest{
		ApiService: a,
		ctx: ctx,
		plateId: plateId,
	}
}

// Execute executes the request
//  @return Plate
func (a *PlatesApiService) GetPlateExecute(r ApiGetPlateRequest) (*Plate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.GetPlate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates/{plate_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plate_id"+"}", url.PathEscape(parameterToString(r.plateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returning != nil {
		localVarQueryParams.Add("returning", parameterToString(*r.returning, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPlatesRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	pageSize *int32
	nextToken *string
	sort *string
	schemaId *string
	schemaFields *map[string]interface{}
	modifiedAt *string
	name *string
	nameIncludes *string
	ancestorStorageId *string
	storageContentsId *string
	storageContentsIds *string
	archiveReason *string
	ids *string
	barcodes *string
	namesAnyOf *string
	namesAnyOfCaseSensitive *string
	returning *string
	creatorIds *string
}

// Number of results to return. Defaults to 50, maximum of 100. 
func (r ApiListPlatesRequest) PageSize(pageSize int32) ApiListPlatesRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListPlatesRequest) NextToken(nextToken string) ApiListPlatesRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListPlatesRequest) Sort(sort string) ApiListPlatesRequest {
	r.sort = &sort
	return r
}

// ID of a schema. Restricts results to those of the specified schema. 
func (r ApiListPlatesRequest) SchemaId(schemaId string) ApiListPlatesRequest {
	r.schemaId = &schemaId
	return r
}

// Schema field value. For Integer, Float, and Date type fields, supports the &gt;&#x3D; and &lt;&#x3D; operators. If present, the schemaId param must also be present. Restricts results to those with a field of whose value matches the filter. 
func (r ApiListPlatesRequest) SchemaFields(schemaFields map[string]interface{}) ApiListPlatesRequest {
	r.schemaFields = &schemaFields
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListPlatesRequest) ModifiedAt(modifiedAt string) ApiListPlatesRequest {
	r.modifiedAt = &modifiedAt
	return r
}

// Name of a plate. Restricts results to those with the specified name.
func (r ApiListPlatesRequest) Name(name string) ApiListPlatesRequest {
	r.name = &name
	return r
}

// Name substring of a plate. Restricts results to those with names that include the provided substring. 
func (r ApiListPlatesRequest) NameIncludes(nameIncludes string) ApiListPlatesRequest {
	r.nameIncludes = &nameIncludes
	return r
}

// ID of a location. Restricts results to those located in the specified storage. 
func (r ApiListPlatesRequest) AncestorStorageId(ancestorStorageId string) ApiListPlatesRequest {
	r.ancestorStorageId = &ancestorStorageId
	return r
}

// ID of a batch, entity, or entity schema. Restricts results to those that hold containers with entities or batches associated with the specified ID. 
func (r ApiListPlatesRequest) StorageContentsId(storageContentsId string) ApiListPlatesRequest {
	r.storageContentsId = &storageContentsId
	return r
}

// Comma-separated list of IDs of batches or entities. Restricts results to those that hold containers with at least one of the specified batches, entities, or batches of the specified entities. 
func (r ApiListPlatesRequest) StorageContentsIds(storageContentsIds string) ApiListPlatesRequest {
	r.storageContentsIds = &storageContentsIds
	return r
}

// Archive reason. Restricts items to those with the specified archive reason. Use \&quot;NOT_ARCHIVED\&quot; to filter for unarchived plates. Use \&quot;ANY_ARCHIVED\&quot; to filter for archived plates regardless of reason. Use \&quot;ANY_ARCHIVED_OR_NOT_ARCHIVED\&quot; to return items for both archived and unarchived. 
func (r ApiListPlatesRequest) ArchiveReason(archiveReason string) ApiListPlatesRequest {
	r.archiveReason = &archiveReason
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListPlatesRequest) Ids(ids string) ApiListPlatesRequest {
	r.ids = &ids
	return r
}

// Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid. 
func (r ApiListPlatesRequest) Barcodes(barcodes string) ApiListPlatesRequest {
	r.barcodes = &barcodes
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity. 
func (r ApiListPlatesRequest) NamesAnyOf(namesAnyOf string) ApiListPlatesRequest {
	r.namesAnyOf = &namesAnyOf
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case sensitive. 
func (r ApiListPlatesRequest) NamesAnyOfCaseSensitive(namesAnyOfCaseSensitive string) ApiListPlatesRequest {
	r.namesAnyOfCaseSensitive = &namesAnyOfCaseSensitive
	return r
}

// Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, &#39;*&#39;. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter). 
func (r ApiListPlatesRequest) Returning(returning string) ApiListPlatesRequest {
	r.returning = &returning
	return r
}

// Comma separated list of users IDs
func (r ApiListPlatesRequest) CreatorIds(creatorIds string) ApiListPlatesRequest {
	r.creatorIds = &creatorIds
	return r
}

func (r ApiListPlatesRequest) Execute() (*PlatesPaginatedList, *http.Response, error) {
	return r.ApiService.ListPlatesExecute(r)
}

/*
ListPlates List plates

List plates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPlatesRequest
*/
func (a *PlatesApiService) ListPlates(ctx context.Context) ApiListPlatesRequest {
	return ApiListPlatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatesPaginatedList
func (a *PlatesApiService) ListPlatesExecute(r ApiListPlatesRequest) (*PlatesPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatesPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.ListPlates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.schemaFields != nil {
		localVarQueryParams.Add("schemaFields", parameterToString(*r.schemaFields, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIncludes != nil {
		localVarQueryParams.Add("nameIncludes", parameterToString(*r.nameIncludes, ""))
	}
	if r.ancestorStorageId != nil {
		localVarQueryParams.Add("ancestorStorageId", parameterToString(*r.ancestorStorageId, ""))
	}
	if r.storageContentsId != nil {
		localVarQueryParams.Add("storageContentsId", parameterToString(*r.storageContentsId, ""))
	}
	if r.storageContentsIds != nil {
		localVarQueryParams.Add("storageContentsIds", parameterToString(*r.storageContentsIds, ""))
	}
	if r.archiveReason != nil {
		localVarQueryParams.Add("archiveReason", parameterToString(*r.archiveReason, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.barcodes != nil {
		localVarQueryParams.Add("barcodes", parameterToString(*r.barcodes, ""))
	}
	if r.namesAnyOf != nil {
		localVarQueryParams.Add("names.anyOf", parameterToString(*r.namesAnyOf, ""))
	}
	if r.namesAnyOfCaseSensitive != nil {
		localVarQueryParams.Add("names.anyOf.caseSensitive", parameterToString(*r.namesAnyOfCaseSensitive, ""))
	}
	if r.returning != nil {
		localVarQueryParams.Add("returning", parameterToString(*r.returning, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creatorIds", parameterToString(*r.creatorIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchivePlatesRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	platesUnarchive *PlatesUnarchive
}

func (r ApiUnarchivePlatesRequest) PlatesUnarchive(platesUnarchive PlatesUnarchive) ApiUnarchivePlatesRequest {
	r.platesUnarchive = &platesUnarchive
	return r
}

func (r ApiUnarchivePlatesRequest) Execute() (*PlatesArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchivePlatesExecute(r)
}

/*
UnarchivePlates Unarchive plates

Unarchive plates and the containers that were archived along with them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchivePlatesRequest
*/
func (a *PlatesApiService) UnarchivePlates(ctx context.Context) ApiUnarchivePlatesRequest {
	return ApiUnarchivePlatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatesArchivalChange
func (a *PlatesApiService) UnarchivePlatesExecute(r ApiUnarchivePlatesRequest) (*PlatesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.UnarchivePlates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.platesUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePlateRequest struct {
	ctx context.Context
	ApiService *PlatesApiService
	plateId string
	returning *string
	plateUpdate *PlateUpdate
}

// Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, &#39;*&#39;. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter). 
func (r ApiUpdatePlateRequest) Returning(returning string) ApiUpdatePlateRequest {
	r.returning = &returning
	return r
}

func (r ApiUpdatePlateRequest) PlateUpdate(plateUpdate PlateUpdate) ApiUpdatePlateRequest {
	r.plateUpdate = &plateUpdate
	return r
}

func (r ApiUpdatePlateRequest) Execute() (*Plate, *http.Response, error) {
	return r.ApiService.UpdatePlateExecute(r)
}

/*
UpdatePlate Update a plate

Update a plate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param plateId
 @return ApiUpdatePlateRequest
*/
func (a *PlatesApiService) UpdatePlate(ctx context.Context, plateId string) ApiUpdatePlateRequest {
	return ApiUpdatePlateRequest{
		ApiService: a,
		ctx: ctx,
		plateId: plateId,
	}
}

// Execute executes the request
//  @return Plate
func (a *PlatesApiService) UpdatePlateExecute(r ApiUpdatePlateRequest) (*Plate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatesApiService.UpdatePlate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plates/{plate_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plate_id"+"}", url.PathEscape(parameterToString(r.plateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returning != nil {
		localVarQueryParams.Add("returning", parameterToString(*r.returning, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plateUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
