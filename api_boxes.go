/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// BoxesApiService BoxesApi service
type BoxesApiService service

type ApiArchiveBoxesRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxesArchive *BoxesArchive
}

func (r ApiArchiveBoxesRequest) BoxesArchive(boxesArchive BoxesArchive) ApiArchiveBoxesRequest {
	r.boxesArchive = &boxesArchive
	return r
}

func (r ApiArchiveBoxesRequest) Execute() (*BoxesArchivalChange, *http.Response, error) {
	return r.ApiService.ArchiveBoxesExecute(r)
}

/*
ArchiveBoxes Archive boxes

Archive boxes and any containers of the boxes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveBoxesRequest
*/
func (a *BoxesApiService) ArchiveBoxes(ctx context.Context) ApiArchiveBoxesRequest {
	return ApiArchiveBoxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BoxesArchivalChange
func (a *BoxesApiService) ArchiveBoxesExecute(r ApiArchiveBoxesRequest) (*BoxesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.ArchiveBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.boxesArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetBoxesRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxIds *string
	barcodes *string
}

func (r ApiBulkGetBoxesRequest) BoxIds(boxIds string) ApiBulkGetBoxesRequest {
	r.boxIds = &boxIds
	return r
}

func (r ApiBulkGetBoxesRequest) Barcodes(barcodes string) ApiBulkGetBoxesRequest {
	r.barcodes = &barcodes
	return r
}

func (r ApiBulkGetBoxesRequest) Execute() (*BoxesBulkGet, *http.Response, error) {
	return r.ApiService.BulkGetBoxesExecute(r)
}

/*
BulkGetBoxes BulkGet boxes

BulkGet boxes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetBoxesRequest
*/
func (a *BoxesApiService) BulkGetBoxes(ctx context.Context) ApiBulkGetBoxesRequest {
	return ApiBulkGetBoxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BoxesBulkGet
func (a *BoxesApiService) BulkGetBoxesExecute(r ApiBulkGetBoxesRequest) (*BoxesBulkGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxesBulkGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.BulkGetBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes:bulk-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.boxIds != nil {
		localVarQueryParams.Add("boxIds", parameterToString(*r.boxIds, ""))
	}
	if r.barcodes != nil {
		localVarQueryParams.Add("barcodes", parameterToString(*r.barcodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBoxRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxCreate *BoxCreate
}

func (r ApiCreateBoxRequest) BoxCreate(boxCreate BoxCreate) ApiCreateBoxRequest {
	r.boxCreate = &boxCreate
	return r
}

func (r ApiCreateBoxRequest) Execute() (*Box, *http.Response, error) {
	return r.ApiService.CreateBoxExecute(r)
}

/*
CreateBox Create a box

Create a box

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBoxRequest
*/
func (a *BoxesApiService) CreateBox(ctx context.Context) ApiCreateBoxRequest {
	return ApiCreateBoxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Box
func (a *BoxesApiService) CreateBoxExecute(r ApiCreateBoxRequest) (*Box, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Box
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.CreateBox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.boxCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoxRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxId string
}

func (r ApiGetBoxRequest) Execute() (*Box, *http.Response, error) {
	return r.ApiService.GetBoxExecute(r)
}

/*
GetBox Get a box

Get a box

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boxId
 @return ApiGetBoxRequest
*/
func (a *BoxesApiService) GetBox(ctx context.Context, boxId string) ApiGetBoxRequest {
	return ApiGetBoxRequest{
		ApiService: a,
		ctx: ctx,
		boxId: boxId,
	}
}

// Execute executes the request
//  @return Box
func (a *BoxesApiService) GetBoxExecute(r ApiGetBoxRequest) (*Box, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Box
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.GetBox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes/{box_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"box_id"+"}", url.PathEscape(parameterToString(r.boxId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBoxContentsRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxId string
	pageSize *int32
	nextToken *string
}

// Number of results to return.
func (r ApiListBoxContentsRequest) PageSize(pageSize int32) ApiListBoxContentsRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListBoxContentsRequest) NextToken(nextToken string) ApiListBoxContentsRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListBoxContentsRequest) Execute() (*BoxContentsPaginatedList, *http.Response, error) {
	return r.ApiService.ListBoxContentsExecute(r)
}

/*
ListBoxContents List a box's contents

List a box's contents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boxId
 @return ApiListBoxContentsRequest
*/
func (a *BoxesApiService) ListBoxContents(ctx context.Context, boxId string) ApiListBoxContentsRequest {
	return ApiListBoxContentsRequest{
		ApiService: a,
		ctx: ctx,
		boxId: boxId,
	}
}

// Execute executes the request
//  @return BoxContentsPaginatedList
func (a *BoxesApiService) ListBoxContentsExecute(r ApiListBoxContentsRequest) (*BoxContentsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxContentsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.ListBoxContents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes/{box_id}/contents"
	localVarPath = strings.Replace(localVarPath, "{"+"box_id"+"}", url.PathEscape(parameterToString(r.boxId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBoxesRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	pageSize *int32
	nextToken *string
	sort *string
	schemaId *string
	schemaFields *map[string]interface{}
	modifiedAt *string
	name *string
	nameIncludes *string
	emptyPositions *int32
	emptyPositionsGte *int32
	emptyPositionsGt *int32
	emptyPositionsLte *int32
	emptyPositionsLt *int32
	emptyContainers *int32
	emptyContainersGte *int32
	emptyContainersGt *int32
	emptyContainersLte *int32
	emptyContainersLt *int32
	ancestorStorageId *string
	storageContentsId *string
	storageContentsIds *string
	archiveReason *string
	ids *string
	barcodes *string
	namesAnyOf *string
	namesAnyOfCaseSensitive *string
	creatorIds *string
}

// Number of results to return. Defaults to 50, maximum of 100. 
func (r ApiListBoxesRequest) PageSize(pageSize int32) ApiListBoxesRequest {
	r.pageSize = &pageSize
	return r
}

// Token for pagination
func (r ApiListBoxesRequest) NextToken(nextToken string) ApiListBoxesRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiListBoxesRequest) Sort(sort string) ApiListBoxesRequest {
	r.sort = &sort
	return r
}

// ID of a schema. Restricts results to those of the specified schema. 
func (r ApiListBoxesRequest) SchemaId(schemaId string) ApiListBoxesRequest {
	r.schemaId = &schemaId
	return r
}

// Schema field value. For Integer, Float, and Date type fields, supports the &gt;&#x3D; and &lt;&#x3D; operators. If present, the schemaId param must also be present. Restricts results to those with a field of whose value matches the filter. 
func (r ApiListBoxesRequest) SchemaFields(schemaFields map[string]interface{}) ApiListBoxesRequest {
	r.schemaFields = &schemaFields
	return r
}

// Datetime, in RFC 3339 format. Supports the &gt; and &lt; operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. &gt; 2017-04-30. 
func (r ApiListBoxesRequest) ModifiedAt(modifiedAt string) ApiListBoxesRequest {
	r.modifiedAt = &modifiedAt
	return r
}

// Name of a box. Restricts results to those with the specified name.
func (r ApiListBoxesRequest) Name(name string) ApiListBoxesRequest {
	r.name = &name
	return r
}

// Name substring of a box. Restricts results to those with names that include the provided substring. 
func (r ApiListBoxesRequest) NameIncludes(nameIncludes string) ApiListBoxesRequest {
	r.nameIncludes = &nameIncludes
	return r
}

// Only return boxes that have the specified number of empty positions 
func (r ApiListBoxesRequest) EmptyPositions(emptyPositions int32) ApiListBoxesRequest {
	r.emptyPositions = &emptyPositions
	return r
}

// Only return boxes that have greater-than or equal-to the specified number of empty positions. 
func (r ApiListBoxesRequest) EmptyPositionsGte(emptyPositionsGte int32) ApiListBoxesRequest {
	r.emptyPositionsGte = &emptyPositionsGte
	return r
}

// Only return boxes that have greater-than the specified number of empty positions. 
func (r ApiListBoxesRequest) EmptyPositionsGt(emptyPositionsGt int32) ApiListBoxesRequest {
	r.emptyPositionsGt = &emptyPositionsGt
	return r
}

// Only return boxes that have less-than or equal-to the specified number of empty positions. 
func (r ApiListBoxesRequest) EmptyPositionsLte(emptyPositionsLte int32) ApiListBoxesRequest {
	r.emptyPositionsLte = &emptyPositionsLte
	return r
}

// Only return boxes that have less-than the specified number of empty positions. 
func (r ApiListBoxesRequest) EmptyPositionsLt(emptyPositionsLt int32) ApiListBoxesRequest {
	r.emptyPositionsLt = &emptyPositionsLt
	return r
}

// Only return boxes that have the specified number of empty containers (containers without contents). 
func (r ApiListBoxesRequest) EmptyContainers(emptyContainers int32) ApiListBoxesRequest {
	r.emptyContainers = &emptyContainers
	return r
}

// Only return boxes that have greater-than or equal-to the specified number of empty containers (containers without contents). 
func (r ApiListBoxesRequest) EmptyContainersGte(emptyContainersGte int32) ApiListBoxesRequest {
	r.emptyContainersGte = &emptyContainersGte
	return r
}

// Only return boxes that have greater-than the specified number of empty containers (containers without contents). 
func (r ApiListBoxesRequest) EmptyContainersGt(emptyContainersGt int32) ApiListBoxesRequest {
	r.emptyContainersGt = &emptyContainersGt
	return r
}

// Only return boxes that have less-than or equal-to the specified number of empty containers (containers without contents). 
func (r ApiListBoxesRequest) EmptyContainersLte(emptyContainersLte int32) ApiListBoxesRequest {
	r.emptyContainersLte = &emptyContainersLte
	return r
}

// Only return boxes that have less-than the specified number of empty containers (containers without contents). 
func (r ApiListBoxesRequest) EmptyContainersLt(emptyContainersLt int32) ApiListBoxesRequest {
	r.emptyContainersLt = &emptyContainersLt
	return r
}

// ID of a location. Restricts results to those located in the specified storage. 
func (r ApiListBoxesRequest) AncestorStorageId(ancestorStorageId string) ApiListBoxesRequest {
	r.ancestorStorageId = &ancestorStorageId
	return r
}

// ID of a batch, entity, or entity schema. Restricts results to those that hold containers with entities or batches associated with the specified ID. 
func (r ApiListBoxesRequest) StorageContentsId(storageContentsId string) ApiListBoxesRequest {
	r.storageContentsId = &storageContentsId
	return r
}

// Comma-separated list of IDs of batches or entities. Restricts results to those that hold containers with at least one of the specified batches, entities, or batches of the specified entities. 
func (r ApiListBoxesRequest) StorageContentsIds(storageContentsIds string) ApiListBoxesRequest {
	r.storageContentsIds = &storageContentsIds
	return r
}

// Archive reason. Restricts items to those with the specified archive reason. Use \&quot;NOT_ARCHIVED\&quot; to filter for unarchived boxes. Use \&quot;ANY_ARCHIVED\&quot; to filter for archived boxes regardless of reason. Use \&quot;ANY_ARCHIVED_OR_NOT_ARCHIVED\&quot; to return items for both archived and unarchived. 
func (r ApiListBoxesRequest) ArchiveReason(archiveReason string) ApiListBoxesRequest {
	r.archiveReason = &archiveReason
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListBoxesRequest) Ids(ids string) ApiListBoxesRequest {
	r.ids = &ids
	return r
}

// Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid. 
func (r ApiListBoxesRequest) Barcodes(barcodes string) ApiListBoxesRequest {
	r.barcodes = &barcodes
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity. 
func (r ApiListBoxesRequest) NamesAnyOf(namesAnyOf string) ApiListBoxesRequest {
	r.namesAnyOf = &namesAnyOf
	return r
}

// Comma-separated list of names. Restricts results to those that match any of the specified names, case sensitive. 
func (r ApiListBoxesRequest) NamesAnyOfCaseSensitive(namesAnyOfCaseSensitive string) ApiListBoxesRequest {
	r.namesAnyOfCaseSensitive = &namesAnyOfCaseSensitive
	return r
}

// Comma separated list of users IDs
func (r ApiListBoxesRequest) CreatorIds(creatorIds string) ApiListBoxesRequest {
	r.creatorIds = &creatorIds
	return r
}

func (r ApiListBoxesRequest) Execute() (*BoxesPaginatedList, *http.Response, error) {
	return r.ApiService.ListBoxesExecute(r)
}

/*
ListBoxes List boxes

List boxes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBoxesRequest
*/
func (a *BoxesApiService) ListBoxes(ctx context.Context) ApiListBoxesRequest {
	return ApiListBoxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BoxesPaginatedList
func (a *BoxesApiService) ListBoxesExecute(r ApiListBoxesRequest) (*BoxesPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxesPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.ListBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.schemaFields != nil {
		localVarQueryParams.Add("schemaFields", parameterToString(*r.schemaFields, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modifiedAt", parameterToString(*r.modifiedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIncludes != nil {
		localVarQueryParams.Add("nameIncludes", parameterToString(*r.nameIncludes, ""))
	}
	if r.emptyPositions != nil {
		localVarQueryParams.Add("emptyPositions", parameterToString(*r.emptyPositions, ""))
	}
	if r.emptyPositionsGte != nil {
		localVarQueryParams.Add("emptyPositions.gte", parameterToString(*r.emptyPositionsGte, ""))
	}
	if r.emptyPositionsGt != nil {
		localVarQueryParams.Add("emptyPositions.gt", parameterToString(*r.emptyPositionsGt, ""))
	}
	if r.emptyPositionsLte != nil {
		localVarQueryParams.Add("emptyPositions.lte", parameterToString(*r.emptyPositionsLte, ""))
	}
	if r.emptyPositionsLt != nil {
		localVarQueryParams.Add("emptyPositions.lt", parameterToString(*r.emptyPositionsLt, ""))
	}
	if r.emptyContainers != nil {
		localVarQueryParams.Add("emptyContainers", parameterToString(*r.emptyContainers, ""))
	}
	if r.emptyContainersGte != nil {
		localVarQueryParams.Add("emptyContainers.gte", parameterToString(*r.emptyContainersGte, ""))
	}
	if r.emptyContainersGt != nil {
		localVarQueryParams.Add("emptyContainers.gt", parameterToString(*r.emptyContainersGt, ""))
	}
	if r.emptyContainersLte != nil {
		localVarQueryParams.Add("emptyContainers.lte", parameterToString(*r.emptyContainersLte, ""))
	}
	if r.emptyContainersLt != nil {
		localVarQueryParams.Add("emptyContainers.lt", parameterToString(*r.emptyContainersLt, ""))
	}
	if r.ancestorStorageId != nil {
		localVarQueryParams.Add("ancestorStorageId", parameterToString(*r.ancestorStorageId, ""))
	}
	if r.storageContentsId != nil {
		localVarQueryParams.Add("storageContentsId", parameterToString(*r.storageContentsId, ""))
	}
	if r.storageContentsIds != nil {
		localVarQueryParams.Add("storageContentsIds", parameterToString(*r.storageContentsIds, ""))
	}
	if r.archiveReason != nil {
		localVarQueryParams.Add("archiveReason", parameterToString(*r.archiveReason, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.barcodes != nil {
		localVarQueryParams.Add("barcodes", parameterToString(*r.barcodes, ""))
	}
	if r.namesAnyOf != nil {
		localVarQueryParams.Add("names.anyOf", parameterToString(*r.namesAnyOf, ""))
	}
	if r.namesAnyOfCaseSensitive != nil {
		localVarQueryParams.Add("names.anyOf.caseSensitive", parameterToString(*r.namesAnyOfCaseSensitive, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creatorIds", parameterToString(*r.creatorIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveBoxesRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxesUnarchive *BoxesUnarchive
}

func (r ApiUnarchiveBoxesRequest) BoxesUnarchive(boxesUnarchive BoxesUnarchive) ApiUnarchiveBoxesRequest {
	r.boxesUnarchive = &boxesUnarchive
	return r
}

func (r ApiUnarchiveBoxesRequest) Execute() (*BoxesArchivalChange, *http.Response, error) {
	return r.ApiService.UnarchiveBoxesExecute(r)
}

/*
UnarchiveBoxes Unarchive boxes

Unarchive boxes and the containers that were archived along with them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveBoxesRequest
*/
func (a *BoxesApiService) UnarchiveBoxes(ctx context.Context) ApiUnarchiveBoxesRequest {
	return ApiUnarchiveBoxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BoxesArchivalChange
func (a *BoxesApiService) UnarchiveBoxesExecute(r ApiUnarchiveBoxesRequest) (*BoxesArchivalChange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxesArchivalChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.UnarchiveBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.boxesUnarchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBoxRequest struct {
	ctx context.Context
	ApiService *BoxesApiService
	boxId string
	boxUpdate *BoxUpdate
}

func (r ApiUpdateBoxRequest) BoxUpdate(boxUpdate BoxUpdate) ApiUpdateBoxRequest {
	r.boxUpdate = &boxUpdate
	return r
}

func (r ApiUpdateBoxRequest) Execute() (*Box, *http.Response, error) {
	return r.ApiService.UpdateBoxExecute(r)
}

/*
UpdateBox Update a box

Update a box

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param boxId
 @return ApiUpdateBoxRequest
*/
func (a *BoxesApiService) UpdateBox(ctx context.Context, boxId string) ApiUpdateBoxRequest {
	return ApiUpdateBoxRequest{
		ApiService: a,
		ctx: ctx,
		boxId: boxId,
	}
}

// Execute executes the request
//  @return Box
func (a *BoxesApiService) UpdateBoxExecute(r ApiUpdateBoxRequest) (*Box, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Box
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BoxesApiService.UpdateBox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/boxes/{box_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"box_id"+"}", url.PathEscape(parameterToString(r.boxId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.boxUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
