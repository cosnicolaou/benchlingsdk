/*
Benchling API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package benchlingsdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AssayResultsApiService AssayResultsApi service
type AssayResultsApiService service

type ApiAbortAssayResultsTransactionRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	transactionId string
}

func (r ApiAbortAssayResultsTransactionRequest) Execute() (*AssayResultTransactionCreateResponse, *http.Response, error) {
	return r.ApiService.AbortAssayResultsTransactionExecute(r)
}

/*
AbortAssayResultsTransaction Abort a transaction

Aborting a transaction will discard all uploaded results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId
 @return ApiAbortAssayResultsTransactionRequest
*/
func (a *AssayResultsApiService) AbortAssayResultsTransaction(ctx context.Context, transactionId string) ApiAbortAssayResultsTransactionRequest {
	return ApiAbortAssayResultsTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return AssayResultTransactionCreateResponse
func (a *AssayResultsApiService) AbortAssayResultsTransactionExecute(r ApiAbortAssayResultsTransactionRequest) (*AssayResultTransactionCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultTransactionCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.AbortAssayResultsTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/result-transactions/{transaction_id}:abort"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", url.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveAssayResultsRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	assayResultsArchive *AssayResultsArchive
}

func (r ApiArchiveAssayResultsRequest) AssayResultsArchive(assayResultsArchive AssayResultsArchive) ApiArchiveAssayResultsRequest {
	r.assayResultsArchive = &assayResultsArchive
	return r
}

func (r ApiArchiveAssayResultsRequest) Execute() (*AssayResultIdsResponse, *http.Response, error) {
	return r.ApiService.ArchiveAssayResultsExecute(r)
}

/*
ArchiveAssayResults Archive 1 or more results.

**Only results that have not been added to a Notebook Entry can be Archived.**
Once results are attached to a notebook entry, they are tracked in the history of that notebook entry, and cannot be archived.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveAssayResultsRequest
*/
func (a *AssayResultsApiService) ArchiveAssayResults(ctx context.Context) ApiArchiveAssayResultsRequest {
	return ApiArchiveAssayResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultIdsResponse
func (a *AssayResultsApiService) ArchiveAssayResultsExecute(r ApiArchiveAssayResultsRequest) (*AssayResultIdsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultIdsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.ArchiveAssayResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results:archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayResultsArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetAssayResultsRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	assayResultIds *string
}

// Comma-separated list of assay result IDs.
func (r ApiBulkGetAssayResultsRequest) AssayResultIds(assayResultIds string) ApiBulkGetAssayResultsRequest {
	r.assayResultIds = &assayResultIds
	return r
}

func (r ApiBulkGetAssayResultsRequest) Execute() (*AssayResultsBulkGet, *http.Response, error) {
	return r.ApiService.BulkGetAssayResultsExecute(r)
}

/*
BulkGetAssayResults Gets multiple results specified by a list of IDs.

Up to 200 IDs can be specified at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkGetAssayResultsRequest
*/
func (a *AssayResultsApiService) BulkGetAssayResults(ctx context.Context) ApiBulkGetAssayResultsRequest {
	return ApiBulkGetAssayResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultsBulkGet
func (a *AssayResultsApiService) BulkGetAssayResultsExecute(r ApiBulkGetAssayResultsRequest) (*AssayResultsBulkGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultsBulkGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.BulkGetAssayResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results:bulk-get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assayResultIds == nil {
		return localVarReturnValue, nil, reportError("assayResultIds is required and must be specified")
	}

	localVarQueryParams.Add("assayResultIds", parameterToString(*r.assayResultIds, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommitAssayResultsTransactionRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	transactionId string
}

func (r ApiCommitAssayResultsTransactionRequest) Execute() (*AssayResultTransactionCreateResponse, *http.Response, error) {
	return r.ApiService.CommitAssayResultsTransactionExecute(r)
}

/*
CommitAssayResultsTransaction Commit a transaction

Committing a transaction will cause all results that have been uploaded to be saved and visible to others.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId
 @return ApiCommitAssayResultsTransactionRequest
*/
func (a *AssayResultsApiService) CommitAssayResultsTransaction(ctx context.Context, transactionId string) ApiCommitAssayResultsTransactionRequest {
	return ApiCommitAssayResultsTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return AssayResultTransactionCreateResponse
func (a *AssayResultsApiService) CommitAssayResultsTransactionExecute(r ApiCommitAssayResultsTransactionRequest) (*AssayResultTransactionCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultTransactionCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.CommitAssayResultsTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/result-transactions/{transaction_id}:commit"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", url.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssayResultsRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	assayResultsBulkCreateRequest *AssayResultsBulkCreateRequest
}

func (r ApiCreateAssayResultsRequest) AssayResultsBulkCreateRequest(assayResultsBulkCreateRequest AssayResultsBulkCreateRequest) ApiCreateAssayResultsRequest {
	r.assayResultsBulkCreateRequest = &assayResultsBulkCreateRequest
	return r
}

func (r ApiCreateAssayResultsRequest) Execute() (*AssayResultsCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAssayResultsExecute(r)
}

/*
CreateAssayResults Create 1 or more results.

Create 1 or more results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssayResultsRequest
*/
func (a *AssayResultsApiService) CreateAssayResults(ctx context.Context) ApiCreateAssayResultsRequest {
	return ApiCreateAssayResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultsCreateResponse
func (a *AssayResultsApiService) CreateAssayResultsExecute(r ApiCreateAssayResultsRequest) (*AssayResultsCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultsCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.CreateAssayResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayResultsBulkCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssayResultsInTransactionRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	transactionId string
	assayResultsBulkCreateRequest *AssayResultsBulkCreateRequest
}

func (r ApiCreateAssayResultsInTransactionRequest) AssayResultsBulkCreateRequest(assayResultsBulkCreateRequest AssayResultsBulkCreateRequest) ApiCreateAssayResultsInTransactionRequest {
	r.assayResultsBulkCreateRequest = &assayResultsBulkCreateRequest
	return r
}

func (r ApiCreateAssayResultsInTransactionRequest) Execute() (*AssayResultsCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAssayResultsInTransactionExecute(r)
}

/*
CreateAssayResultsInTransaction Create results in a transaction

Create results in a transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId
 @return ApiCreateAssayResultsInTransactionRequest
*/
func (a *AssayResultsApiService) CreateAssayResultsInTransaction(ctx context.Context, transactionId string) ApiCreateAssayResultsInTransactionRequest {
	return ApiCreateAssayResultsInTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return AssayResultsCreateResponse
func (a *AssayResultsApiService) CreateAssayResultsInTransactionExecute(r ApiCreateAssayResultsInTransactionRequest) (*AssayResultsCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultsCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.CreateAssayResultsInTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/result-transactions/{transaction_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", url.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayResultsBulkCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssayResultsTransactionRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
}

func (r ApiCreateAssayResultsTransactionRequest) Execute() (*AssayResultTransactionCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAssayResultsTransactionExecute(r)
}

/*
CreateAssayResultsTransaction Create a transaction

Transactions allow results to be upload in multiple requests. This endpoint lets you create a transaction. You can then upload results to the transaction, abort the transaction, or commit the transaction.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssayResultsTransactionRequest
*/
func (a *AssayResultsApiService) CreateAssayResultsTransaction(ctx context.Context) ApiCreateAssayResultsTransactionRequest {
	return ApiCreateAssayResultsTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultTransactionCreateResponse
func (a *AssayResultsApiService) CreateAssayResultsTransactionExecute(r ApiCreateAssayResultsTransactionRequest) (*AssayResultTransactionCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultTransactionCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.CreateAssayResultsTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/result-transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssayResultRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	assayResultId string
}

func (r ApiGetAssayResultRequest) Execute() (*AssayResult, *http.Response, error) {
	return r.ApiService.GetAssayResultExecute(r)
}

/*
GetAssayResult Get a result

Get a result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assayResultId
 @return ApiGetAssayResultRequest
*/
func (a *AssayResultsApiService) GetAssayResult(ctx context.Context, assayResultId string) ApiGetAssayResultRequest {
	return ApiGetAssayResultRequest{
		ApiService: a,
		ctx: ctx,
		assayResultId: assayResultId,
	}
}

// Execute executes the request
//  @return AssayResult
func (a *AssayResultsApiService) GetAssayResultExecute(r ApiGetAssayResultRequest) (*AssayResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.GetAssayResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results/{assay_result_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assay_result_id"+"}", url.PathEscape(parameterToString(r.assayResultId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssayResultsRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	schemaId *string
	createdAtLt *string
	createdAtGt *string
	createdAtLte *string
	createdAtGte *string
	minCreatedTime *int32
	maxCreatedTime *int32
	sort *string
	nextToken *string
	pageSize *int32
	entityIds *string
	storageIds *string
	assayRunIds *string
	ids *string
}

// ID of the assay result schema to filter by
func (r ApiListAssayResultsRequest) SchemaId(schemaId string) ApiListAssayResultsRequest {
	r.schemaId = &schemaId
	return r
}

// Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created before the specified time. e.g. &lt; 2017-04-30. 
func (r ApiListAssayResultsRequest) CreatedAtLt(createdAtLt string) ApiListAssayResultsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created after the specified time. e.g. &gt; 2017-04-30. 
func (r ApiListAssayResultsRequest) CreatedAtGt(createdAtGt string) ApiListAssayResultsRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created on or before the specified time. e.g. &lt;&#x3D; 2017-04-30. 
func (r ApiListAssayResultsRequest) CreatedAtLte(createdAtLte string) ApiListAssayResultsRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created on or after the specified time. e.g. &gt;&#x3D; 2017-04-30. 
func (r ApiListAssayResultsRequest) CreatedAtGte(createdAtGte string) ApiListAssayResultsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Filter by results created after this unix timestamp
// Deprecated
func (r ApiListAssayResultsRequest) MinCreatedTime(minCreatedTime int32) ApiListAssayResultsRequest {
	r.minCreatedTime = &minCreatedTime
	return r
}

// Filter by results created before this unix timestamp
// Deprecated
func (r ApiListAssayResultsRequest) MaxCreatedTime(maxCreatedTime int32) ApiListAssayResultsRequest {
	r.maxCreatedTime = &maxCreatedTime
	return r
}

// Method by which to order search results. Valid sorts are createdAt (created time, oldest first). Use :asc or :desc to specify ascending or descending order. Default is createdAt:asc. 
func (r ApiListAssayResultsRequest) Sort(sort string) ApiListAssayResultsRequest {
	r.sort = &sort
	return r
}

// Token for pagination
func (r ApiListAssayResultsRequest) NextToken(nextToken string) ApiListAssayResultsRequest {
	r.nextToken = &nextToken
	return r
}

// Number of results to return. Defaults to 50, maximum of 100.
func (r ApiListAssayResultsRequest) PageSize(pageSize int32) ApiListAssayResultsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by comma-separated list of related Entity IDs, maximum of 20.
func (r ApiListAssayResultsRequest) EntityIds(entityIds string) ApiListAssayResultsRequest {
	r.entityIds = &entityIds
	return r
}

// Filter by comma-separated list of related storage (container, box, plate, or location) IDs, maximum of 20. 
func (r ApiListAssayResultsRequest) StorageIds(storageIds string) ApiListAssayResultsRequest {
	r.storageIds = &storageIds
	return r
}

// Filter by comma-separated list of associated AssayRun IDs.
func (r ApiListAssayResultsRequest) AssayRunIds(assayRunIds string) ApiListAssayResultsRequest {
	r.assayRunIds = &assayRunIds
	return r
}

// Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid. 
func (r ApiListAssayResultsRequest) Ids(ids string) ApiListAssayResultsRequest {
	r.ids = &ids
	return r
}

func (r ApiListAssayResultsRequest) Execute() (*AssayResultsPaginatedList, *http.Response, error) {
	return r.ApiService.ListAssayResultsExecute(r)
}

/*
ListAssayResults List results

List results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAssayResultsRequest
*/
func (a *AssayResultsApiService) ListAssayResults(ctx context.Context) ApiListAssayResultsRequest {
	return ApiListAssayResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultsPaginatedList
func (a *AssayResultsApiService) ListAssayResultsExecute(r ApiListAssayResultsRequest) (*AssayResultsPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultsPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.ListAssayResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.schemaId == nil {
		return localVarReturnValue, nil, reportError("schemaId is required and must be specified")
	}

	localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	if r.createdAtLt != nil {
		localVarQueryParams.Add("createdAt.lt", parameterToString(*r.createdAtLt, ""))
	}
	if r.createdAtGt != nil {
		localVarQueryParams.Add("createdAt.gt", parameterToString(*r.createdAtGt, ""))
	}
	if r.createdAtLte != nil {
		localVarQueryParams.Add("createdAt.lte", parameterToString(*r.createdAtLte, ""))
	}
	if r.createdAtGte != nil {
		localVarQueryParams.Add("createdAt.gte", parameterToString(*r.createdAtGte, ""))
	}
	if r.minCreatedTime != nil {
		localVarQueryParams.Add("minCreatedTime", parameterToString(*r.minCreatedTime, ""))
	}
	if r.maxCreatedTime != nil {
		localVarQueryParams.Add("maxCreatedTime", parameterToString(*r.maxCreatedTime, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("nextToken", parameterToString(*r.nextToken, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.entityIds != nil {
		localVarQueryParams.Add("entityIds", parameterToString(*r.entityIds, ""))
	}
	if r.storageIds != nil {
		localVarQueryParams.Add("storageIds", parameterToString(*r.storageIds, ""))
	}
	if r.assayRunIds != nil {
		localVarQueryParams.Add("assayRunIds", parameterToString(*r.assayRunIds, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnarchiveAssayResultsRequest struct {
	ctx context.Context
	ApiService *AssayResultsApiService
	assayResultIdsRequest *AssayResultIdsRequest
}

func (r ApiUnarchiveAssayResultsRequest) AssayResultIdsRequest(assayResultIdsRequest AssayResultIdsRequest) ApiUnarchiveAssayResultsRequest {
	r.assayResultIdsRequest = &assayResultIdsRequest
	return r
}

func (r ApiUnarchiveAssayResultsRequest) Execute() (*AssayResultIdsResponse, *http.Response, error) {
	return r.ApiService.UnarchiveAssayResultsExecute(r)
}

/*
UnarchiveAssayResults Unarchive 1 or more results.

Unarchive 1 or more results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnarchiveAssayResultsRequest
*/
func (a *AssayResultsApiService) UnarchiveAssayResults(ctx context.Context) ApiUnarchiveAssayResultsRequest {
	return ApiUnarchiveAssayResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssayResultIdsResponse
func (a *AssayResultsApiService) UnarchiveAssayResultsExecute(r ApiUnarchiveAssayResultsRequest) (*AssayResultIdsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssayResultIdsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssayResultsApiService.UnarchiveAssayResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assay-results:unarchive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assayResultIdsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
